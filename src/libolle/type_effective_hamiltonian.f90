module type_effective_hamiltonian
!!
!! Local-orbital realspace electronic Hamiltonian. Has to be pre-generated by
!! FHI-Aims, but can after that be post-processesed in a variety of ways.
!!
use konstanter, only: r8,i4,i8,lo_iou,lo_imag,lo_hugeint,lo_huge,lo_pi,lo_twopi,lo_freqtol,lo_sqtol,&
    lo_exitcode_param,lo_exitcode_blaslapack,lo_exitcode_symmetry
use gottochblandat, only: tochar,walltime,lo_sqnorm,lo_determ,lo_chop
use mpi_wrappers, only: lo_mpi_helper,lo_stop_gracefully
use type_crystalstructure, only: lo_crystalstructure
use hdf5_wrappers, only: lo_hdf5_helper
use lo_memtracker, only: lo_mem_helper
use lo_sorting, only: lo_return_unique
use type_blas_lapack_wrappers, only: lo_zhegv,lo_gemv
use type_qpointmesh, only: lo_qpoint
use type_symmetryoperation, only: lo_spacegroup_operation
implicit none

private
public :: lo_effective_hamiltonian
public :: lo_effective_hamiltonian_atom_pair

!> pair in the effective Hamiltonian
type lo_effective_hamiltonian_atom_pair
    ! First section pertains to straight pair things, normal stuff

    !> first atom in pair
    integer :: a1=-lo_hugeint
    !> second atom in pair
    integer :: a2=-lo_hugeint
    !> number of basis functions on first atom
    integer :: nb1=-lo_hugeint
    !> number of basis functions on second atom
    integer :: nb2=-lo_hugeint
    !> pair vector
    real(r8), dimension(3) :: v=-lo_huge
    !> lattice vector
    real(r8), dimension(3) :: lv=-lo_huge
    !> Hamiltonian (b1,b2,ispin)
    real(r8), dimension(:,:,:), allocatable :: hamiltonian
    !> Overlap matrix (b1,b2)
    real(r8), dimension(:,:), allocatable :: overlap

    ! Now we have things pertaining to triplets

    !> number of triplets in the Hamiltonian expansion
    integer :: n_triplet_ham=-lo_hugeint
    !> Which atoms are involved
    integer, dimension(:), allocatable :: triplet_ham_ind
    !> Global indices to atoms that are involved in triplets
    integer, dimension(:), allocatable :: triplet_ham_global_ind
    !> Absolute vector to third atom
    real(r8), dimension(:,:), allocatable :: triplet_ham_v
    !> Lattice vector to third atom
    real(r8), dimension(:,:), allocatable :: triplet_ham_lv
    !> Hamiltonian derivative with respect to triplet (b1,b2,xyz,itriplet,ispin)
    real(r8), dimension(:,:,:,:,:), allocatable :: dHdtau

    !> number of triplets in the overlap expansion
    integer :: n_triplet_ovl=-lo_hugeint
    !> Global indices to atoms that are involved in triplets
    integer, dimension(2) :: triplet_ovl_global_ind
    !> Overlap derivative with respect to triplet (b1,b2,xyz,itriplet)
    real(r8), dimension(:,:,:,:), allocatable :: dOdtau

    !> intermediate quantities needed for the double Fourier transform
    complex(r8), dimension(:,:,:), allocatable :: dHdqs
    complex(r8), dimension(:,:), allocatable :: dOdqs
end type

!> an atom in the effective hamiltonian, information pertaining to the basis set.
type lo_effective_hamiltonian_atom
    !> number of basis functions on this atom
    integer :: n_basis=-lo_hugeint
    !> l quantum number per basis function
    integer, dimension(:), allocatable :: basis_l
    integer, dimension(:), allocatable :: basis_m
    integer, dimension(:), allocatable :: basis_fn
    real(r8), dimension(:), allocatable :: basis_cutoff
    !> how many groups of constant l are there
    integer :: n_basis_groups_on_atom=-lo_hugeint
    !> l quantum number for each group (n_basis_groups_on_atom)
    integer, dimension(:), allocatable :: basis_group_l
    !> groups of basis functions (2,n_basis_groups_on_atom), start and end of indices
    integer, dimension(:,:), allocatable :: basis_group
end type

!> Completely rearranged AIMS Hamiltonian
type lo_effective_hamiltonian
    !> how many atoms
    integer :: n_atom=-lo_hugeint
    !> number of pairs in the Hamiltonian
    integer :: n_pair=-lo_hugeint
    !> number of electrons
    real(r8) :: n_electron=-lo_huge
    !> number of spin channels
    integer :: n_spin=-lo_hugeint
    !> number of basis functions
    integer :: n_basis=-lo_hugeint
    !> number of bands to consider
    integer :: n_band=-lo_hugeint
    !> shift of the basis functions per atom
    integer, dimension(:), allocatable :: basis_index_shift
    !> info about each atom
    type(lo_effective_hamiltonian_atom), dimension(:), allocatable :: atom
    !> pairs
    type(lo_effective_hamiltonian_atom_pair), dimension(:), allocatable :: pair
    contains
        !> initialize from file
        procedure :: read_from_hdf5
        !> write to file
        procedure :: write_to_hdf5
        !> solve generalized eigenproblem at a given k-point
        procedure :: solve_eigenproblem
        !> electron-phonon matrix element
        procedure :: matrixelement
        !> rotation matrix for eigenvectors
        procedure :: kspace_rotation_matrix
        !> size in memory, in bytes
        procedure :: size_in_mem=>effham_size_in_mem
end type

contains

!> Solve the KS eigenproblem.
subroutine solve_eigenproblem(eh,kp,eigenvalues,mem,eigenvectors,groupvelocities)
    !> AIMS hamiltonian
    class(lo_effective_hamiltonian), intent(in) :: eh
    !> k-point
    class(lo_qpoint), intent(in) :: kp
    !> eigenvalues to the KS problem (n_band,nspin)
    real(r8), dimension(:,:), intent(out) :: eigenvalues
    !> memory tracker
    type(lo_mem_helper), intent(inout) :: mem
    !> eigenvectors to the KS problem (n_basis,n_band,nspin)
    complex(r8), dimension(:,:,:), intent(out), optional :: eigenvectors
    !> group velocities (3,n_band,nspin)
    real(r8), dimension(:,:,:), intent(out), optional :: groupvelocities

    complex(r8), dimension(:,:,:,:), allocatable :: dHdk
    complex(r8), dimension(:,:,:), allocatable :: dOdk
    complex(r8), dimension(:,:,:), allocatable :: wHam
    complex(r8), dimension(:,:), allocatable :: wOVL
    real(r8), dimension(:,:), allocatable :: wr
    logical :: ddk

    ! Make some temporary space
    init: block
        call mem%allocate(wHam,[eh%n_basis,eh%n_basis,eh%n_spin],persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
        call mem%allocate(wOVL,[eh%n_basis,eh%n_basis]          ,persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
        call mem%allocate(wr  ,[eh%n_basis,eh%n_spin ]          ,persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
        wHam=0.0_r8
        wOvl=0.0_r8
        wr=0.0_r8
        if ( present(groupvelocities) ) then
            ddk=.true.
            call mem%allocate(dHdk,[eh%n_basis,eh%n_basis,3,eh%n_spin],persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
            call mem%allocate(dOdk,[eh%n_basis,eh%n_basis,3]          ,persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
            dHdk=0.0_r8
            dOdk=0.0_r8
        else
            ddk=.false.
        endif
    end block init

    ! Fourier transform the Hamiltonian and overlap
    fftham: block
        complex(r8) :: expikr
        real(r8), dimension(3) :: lv,kv
        real(r8) :: kdotr
        integer :: a1,a2,i1,i2,j1,j2,ispin
        integer :: ipair

        kv=kp%r
        do ipair=1,eh%n_pair
            a1=eh%pair(ipair)%a1
            a2=eh%pair(ipair)%a2
            lv=eh%pair(ipair)%lv
            kdotr=dot_product(lv,kv)*lo_twopi
            expikr=cmplx(cos(kdotr),sin(kdotr),r8)
            ! Where should it be added?
            i1=eh%basis_index_shift(a1)+1
            i2=eh%basis_index_shift(a1)+eh%atom(a1)%n_basis
            j1=eh%basis_index_shift(a2)+1
            j2=eh%basis_index_shift(a2)+eh%atom(a2)%n_basis
            ! first overlap
            wOVL(i1:i2,j1:j2)=wOVL(i1:i2,j1:j2)+eh%pair(ipair)%overlap*expikr
            if ( ddk ) then
                dOdk(i1:i2,j1:j2,1)=dOdk(i1:i2,j1:j2,1)+eh%pair(ipair)%overlap(:,:)*expikr*lo_twopi*lv(1)*lo_imag
                dOdk(i1:i2,j1:j2,2)=dOdk(i1:i2,j1:j2,2)+eh%pair(ipair)%overlap(:,:)*expikr*lo_twopi*lv(2)*lo_imag
                dOdk(i1:i2,j1:j2,3)=dOdk(i1:i2,j1:j2,3)+eh%pair(ipair)%overlap(:,:)*expikr*lo_twopi*lv(3)*lo_imag
            endif
            ! then the Hamiltonian
            do ispin=1,eh%n_spin
                wHAM(i1:i2,j1:j2,ispin)=wHAM(i1:i2,j1:j2,ispin)+eh%pair(ipair)%hamiltonian(:,:,ispin)*expikr
                if ( ddk ) then
                    dHdk(i1:i2,j1:j2,1,ispin)=dHdk(i1:i2,j1:j2,1,ispin)+eh%pair(ipair)%hamiltonian(:,:,ispin)*expikr*lo_twopi*lv(1)*lo_imag
                    dHdk(i1:i2,j1:j2,2,ispin)=dHdk(i1:i2,j1:j2,2,ispin)+eh%pair(ipair)%hamiltonian(:,:,ispin)*expikr*lo_twopi*lv(2)*lo_imag
                    dHdk(i1:i2,j1:j2,3,ispin)=dHdk(i1:i2,j1:j2,3,ispin)+eh%pair(ipair)%hamiltonian(:,:,ispin)*expikr*lo_twopi*lv(3)*lo_imag
                endif
            enddo
        enddo
    end block fftham

    ! Depending on my mood, I can solve this a few different ways. No matter how, at the end of this block I should
    ! have the eigenvectors in wHAM, and eigenvalues in wr. Notable, only use slvr=1, seems to be the best by far.
    straightlapack: block
        complex(r8), dimension(:,:), allocatable :: wA
        integer :: ispin,ierr

        call mem%allocate(wA,[eh%n_basis,eh%n_basis],persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
        wA=0.0_r8
        ! Just lapack directly
        do ispin=1,eh%n_spin
            wA=wOVL ! since Lapack tends to destroy things
            call lo_zhegv(wHAM(:,:,ispin),wA,wr(:,ispin),jobz='V',uplo='U',info=ierr)
            if ( ierr .ne. 0 ) then
                call lo_stop_gracefully(['zhegv exit code '//tochar(ierr)],lo_exitcode_blaslapack,__FILE__,__LINE__)
            endif
        enddo
        call mem%deallocate(wA,persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
    end block straightlapack

    ! No matter how I solved it, I should return the answer
    sortanswer: block
        complex(r8), dimension(:), allocatable :: dv
        complex(r8) :: c0,c1
        integer :: ispin,i,dir

        ! Return the solution
        do ispin=1,eh%n_spin
        do i=1,eh%n_band
            eigenvalues(i,ispin)=wr(i,ispin)
            if ( present(eigenvectors) ) then
                eigenvectors(:,i,ispin)=wHAM(:,i,ispin)
            endif
        enddo
        enddo

        ! Also, maybe the group velocities?
        ! v_x = ( < psi | dH | psi > - e < psi | dO | psi > ) / < psi | O | psi >
        if ( ddk ) then
            call mem%allocate(dv,eh%n_basis,persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
            dv=0.0_r8
            do ispin=1,eh%n_spin
            do dir=1,3
                do i=1,eh%n_band
                    ! Start with < psi | dH | psi >
                    call lo_gemv(dHdk(:,:,dir,ispin),wHAM(:,i,ispin),dv,trans='N')
                    c0=dot_product(wHAM(:,i,ispin),dv)
                    ! Then < psi | dO | psi >
                    call lo_gemv(dOdk(:,:,dir),wHAM(:,i,ispin),dv,trans='N')
                    c1=dot_product(wHAM(:,i,ispin),dv)
                    ! Done, if < psi_i | O | psi_i > = 1, which it should be
                    groupvelocities(dir,i,ispin)=real( (c0-wr(i,ispin)*c1),r8)
                    ! And finally < psi | O | psi >
                    ! Luckily, this is not needed! < psi | O | psi > = 1 by definition.
                    !call lo_gemv(wOVL(:,:),wHAM(:,i,ispin),dv,trans='N')
                    !c2=dot_product(wHAM(:,i,ispin),dv)
                    !groupvelocities(dir,i,ispin)=real( (c0-wr(i,ispin)*c1)/c2 )
                enddo
            enddo
            enddo
            call mem%deallocate(dv,persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
        endif
    end block sortanswer

    ! And cleanup
    call mem%deallocate(wHam,persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
    call mem%deallocate(wOVL,persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
    call mem%deallocate(wr  ,persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
    if ( ddk ) then
        call mem%deallocate(dHdk,persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
        call mem%deallocate(dOdk,persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
    endif
end subroutine

!> Calculate the electron-phonon matrix element
subroutine matrixelement(eh,p,phonon_eigenvector,electron_eigenvector_k,electron_eigenvector_kp,&
    energy_k,omega,kvec,qvec,gmn)
    !> effective Hamiltonian
    class(lo_effective_hamiltonian), intent(inout) :: eh
    !> crystal structure
    type(lo_crystalstructure), intent(in) :: p
    !> phonon eigenvector
    complex(r8), dimension(:), intent(in) :: phonon_eigenvector
    !> electron eigenvector at k,iband1
    complex(r8), dimension(:), intent(in) :: electron_eigenvector_k
    !> electron eigenvector at k',iband2
    complex(r8), dimension(:), intent(in) :: electron_eigenvector_kp
    !> electron energy at k,iband1
    real(r8), intent(in) :: energy_k
    !> phonon frequency
    real(r8), intent(in) :: omega
    !> k-vector
    real(r8), dimension(3), intent(in) :: kvec
    !> q-vector
    real(r8), dimension(3), intent(in) :: qvec
    !> matrix element
    complex(r8), intent(out) :: gmn

    ! First transform with the phonon
    qtransform: block
        complex(r8) :: expiqr,c1
        real(r8), dimension(3) :: lv
        real(r8) :: qdotr
        integer :: a1,a2,a3,ipair,itrip,ialpha,ispin,lm

        ! First the Hamiltonian?
        do ipair=1,eh%n_pair
            if ( eh%pair(ipair)%n_triplet_ham .eq. 0 ) cycle
            eh%pair(ipair)%dHdqs=0.0_r8
            a1=eh%pair(ipair)%a1
            a2=eh%pair(ipair)%a2
            do itrip=1,eh%pair(ipair)%n_triplet_ham
                a3=eh%pair(ipair)%triplet_ham_ind(itrip)
                lv=eh%pair(ipair)%triplet_ham_lv(:,itrip)
                qdotr=dot_product(lv,qvec)*lo_twopi
                expiqr=cmplx(cos(qdotr),sin(qdotr),r8)
                do ispin=1,eh%n_spin
                do ialpha=1,3
                    ! what component we are on?
                    lm=(a3-1)*3+ialpha
                    c1=phonon_eigenvector(lm)*expiqr*p%invsqrtmass(a3)
                    eh%pair(ipair)%dHdqs(:,:,ispin)=eh%pair(ipair)%dHdqs(:,:,ispin)+eh%pair(ipair)%dHdtau(:,:,ialpha,itrip,ispin)*c1
                enddo
                enddo
            enddo
        enddo

        ! ! Then the overlap, slightly easier
        do ipair=1,eh%n_pair
            if ( eh%pair(ipair)%n_triplet_ovl .eq. 0 ) cycle
            eh%pair(ipair)%dOdqs=0.0_r8
            a1=eh%pair(ipair)%a1
            a2=eh%pair(ipair)%a2
            lv=eh%pair(ipair)%lv

            ! This should be fairly straightforward. Depends only on a1 and a2, I think.
            qdotr=dot_product(lv,qvec)*lo_twopi ! for a2, for a1 it's 1.
            expiqr=cmplx(cos(qdotr),sin(qdotr),r8)
            do ialpha=1,3
                lm=(a1-1)*3+ialpha
                c1=phonon_eigenvector(lm)*p%invsqrtmass(a1)
                eh%pair(ipair)%dOdqs=eh%pair(ipair)%dOdqs+eh%pair(ipair)%dOdtau(:,:,ialpha,1)*c1

                lm=(a2-1)*3+ialpha
                c1=phonon_eigenvector(lm)*p%invsqrtmass(a2)*expiqr
                eh%pair(ipair)%dOdqs=eh%pair(ipair)%dOdqs+eh%pair(ipair)%dOdtau(:,:,ialpha,2)*c1
            enddo
        enddo
    end block qtransform

    ! Then sandwich it?
    sandwich: block
        complex(r8), dimension(:,:,:), allocatable :: dHdqdk
        complex(r8), dimension(:,:), allocatable :: dOdqdk
        complex(r8), dimension(:), allocatable :: dv
        complex(r8) :: expikr
        real(r8), dimension(3) :: lv
        real(r8) :: kdotr
        integer :: a1,a2,ipair,i1,i2,j1,j2,ispin

        allocate(dHdqdk(eh%n_basis,eh%n_basis,eh%n_spin))
        allocate(dOdqdk(eh%n_basis,eh%n_basis))
        allocate(dv(eh%n_basis))
        dHdqdk=0.0_r8
        dOdqdk=0.0_r8
        dv=0.0_r8
        do ipair=1,eh%n_pair
            ! Get some basics, phasefactors and such
            if ( eh%pair(ipair)%n_triplet_ham .gt. 0 ) then
                a1=eh%pair(ipair)%a1
                a2=eh%pair(ipair)%a2
                lv=eh%pair(ipair)%lv
                kdotr=dot_product(lv,kvec)*lo_twopi
                expikr=cmplx(cos(kdotr),sin(kdotr),r8)
                ! Where should it be added?
                i1=eh%basis_index_shift(a1)+1
                i2=eh%basis_index_shift(a1)+eh%atom(a1)%n_basis
                j1=eh%basis_index_shift(a2)+1
                j2=eh%basis_index_shift(a2)+eh%atom(a2)%n_basis
                do ispin=1,eh%n_spin
                    dHdqdk(i1:i2,j1:j2,ispin)=dHdqdk(i1:i2,j1:j2,ispin)+eh%pair(ipair)%dHdqs(:,:,ispin)*expikr
                enddo
            endif

            if ( eh%pair(ipair)%n_triplet_ovl .gt. 0 ) then
                a1=eh%pair(ipair)%a1
                a2=eh%pair(ipair)%a2
                lv=eh%pair(ipair)%lv
                kdotr=dot_product(lv,kvec)*lo_twopi
                expikr=cmplx(cos(kdotr),sin(kdotr),r8)
                ! Where should it be added?
                i1=eh%basis_index_shift(a1)+1
                i2=eh%basis_index_shift(a1)+eh%atom(a1)%n_basis
                j1=eh%basis_index_shift(a2)+1
                j2=eh%basis_index_shift(a2)+eh%atom(a2)%n_basis
                dOdqdk(i1:i2,j1:j2)=dOdqdk(i1:i2,j1:j2)+eh%pair(ipair)%dOdqs(:,:)*expikr
            endif
        enddo

        ! Sandwich?
        !@todo Spin things!!!
        dHdqdk(:,:,1)=dHdqdk(:,:,1)-energy_k*dOdqdk
        dv=matmul(dHdqdk(:,:,1),electron_eigenvector_k)
        !call lo_gemv(dHdqdk(:,:,1),electron_eigenvector_k,dv)
        gmn=dot_product(electron_eigenvector_kp,dv)
        if ( omega .gt. lo_freqtol ) then
            gmn=gmn/sqrt(2*omega)
        else
            gmn=0.0_r8
        endif
    end block sandwich
end subroutine

!> read hamiltonian from file.
subroutine read_from_hdf5(eh,filename,p,nbuffer,mw,mem,verbosity)
    !> hamiltonian
    class(lo_effective_hamiltonian), intent(out) :: eh
    !> filename
    character(len=*), intent(in) :: filename
    !> structure
    type(lo_crystalstructure), intent(in) :: p
    !> Number of buffer bands
    integer, intent(in) :: nbuffer
    !> MPI helper
    type(lo_mpi_helper), intent(inout) :: mw
    !> memory tracker
    type(lo_mem_helper), intent(inout) :: mem
    !> Talk a lot?
    integer, intent(in) :: verbosity

    real(r8) :: timer,t0,t1
    integer :: readrank

    ! Start timers
    timer=walltime()
    t0=timer
    t1=timer

    init: block
        if ( verbosity .gt. 0 ) then
            write(lo_iou,*) ''
            write(lo_iou,*) 'Reading electronic hamiltonian from "'//trim(filename)//'"'
        endif
        ! Which rank should do the reading?
        readrank=mw%n-1
    end block init

    ! Read only on one rank
    if ( mw%r .eq. readrank ) then
    readfile: block
        type(lo_hdf5_helper) :: h5
        real(r8), dimension(:,:), allocatable :: dr
        integer :: i

        call h5%init(__FILE__,__LINE__)
        call h5%open_file('read',trim(filename))

        call h5%read_attribute(eh%n_atom,h5%file_id,'n_atom')
        call h5%read_attribute(eh%n_electron,h5%file_id,'n_electron')
        call h5%read_attribute(eh%n_spin,h5%file_id,'n_spin')
        call h5%read_attribute(eh%n_basis,h5%file_id,'n_basis')
        call h5%read_attribute(eh%n_pair,h5%file_id,'n_pair')
        call h5%read_data(eh%basis_index_shift,h5%file_id,'basis_index_shift')

        ! Decide on the number of bands
        i=ceiling(eh%n_electron/2)+nbuffer
        i=min(i,eh%n_basis)
        eh%n_band=i

        allocate(eh%atom(eh%n_atom))
        allocate(eh%pair(eh%n_pair))
        do i=1,eh%n_atom
            call h5%open_group('read','basis_atom_'//tochar(i))
                call h5%read_data(eh%atom(i)%basis_l,h5%group_id,'basis_l')
                call h5%read_data(eh%atom(i)%basis_m,h5%group_id,'basis_m')
                call h5%read_data(eh%atom(i)%basis_fn,h5%group_id,'basis_fn')
                call h5%read_data(eh%atom(i)%basis_cutoff,h5%group_id,'basis_cutoff')
                eh%atom(i)%n_basis=size(eh%atom(i)%basis_l)
            call h5%close_group()
        enddo

        call h5%read_data(dr,h5%file_id,'pair_vectors')
        do i=1,eh%n_pair
            eh%pair(i)%v=dr(:,i)
        enddo
        deallocate(dr)
        call h5%read_data(dr,h5%file_id,'lattice_vectors')
        do i=1,eh%n_pair
            eh%pair(i)%lv=dr(:,i)
        enddo
        deallocate(dr)

        do i=1,eh%n_pair
            call h5%open_group('read','pair_'//tochar(i))
                call h5%read_attribute(eh%pair(i)%a1,h5%group_id,'atom1')
                call h5%read_attribute(eh%pair(i)%a2,h5%group_id,'atom2')
                call h5%read_attribute(eh%pair(i)%nb1,h5%group_id,'nb1')
                call h5%read_attribute(eh%pair(i)%nb2,h5%group_id,'nb2')
                call h5%read_data(eh%pair(i)%overlap,h5%group_id,'overlap')
                call h5%read_data(eh%pair(i)%hamiltonian,h5%group_id,'hamiltonian')
                ! Triplet expansion things
                call h5%read_attribute(eh%pair(i)%n_triplet_ham,h5%group_id,'ntriplet_ham')
                if ( eh%pair(i)%n_triplet_ham .gt. 0 ) then
                    call h5%read_data(eh%pair(i)%triplet_ham_ind,h5%group_id,'triplet_ham_ind')
                    call h5%read_data(eh%pair(i)%triplet_ham_v,h5%group_id,'triplet_ham_v')
                    call h5%read_data(eh%pair(i)%triplet_ham_lv,h5%group_id,'triplet_ham_lv')
                    call h5%read_data(eh%pair(i)%dHdtau,h5%group_id,'dHdtau')
                endif
                call h5%read_attribute(eh%pair(i)%n_triplet_ovl,h5%group_id,'ntriplet_ovl')
                if ( eh%pair(i)%n_triplet_ovl .gt. 0 ) then
                    call h5%read_data(eh%pair(i)%dOdtau,h5%group_id,'dOdtau')
                endif
            call h5%close_group()
        enddo
        call h5%close_file()
        call h5%destroy(__FILE__,__LINE__)
    end block readfile
    endif

    ! Now spread the Hamiltonian over ranks (if there is more than one rank, that is)
    if ( mw%n .gt. 1 ) then
    commham: block
        character, dimension(:), allocatable :: buf
        integer(i8) :: bytes
        integer :: pos,size_packed
        integer :: ipair,iatom

        ! Start counting the size of the Hamiltonian if packed into buffer
        if ( mw%r .eq. readrank ) then
            bytes=0_i8
            bytes=bytes+storage_size(eh%n_atom    )
            bytes=bytes+storage_size(eh%n_electron)
            bytes=bytes+storage_size(eh%n_spin    )
            bytes=bytes+storage_size(eh%n_basis   )
            bytes=bytes+storage_size(eh%n_pair    )
            bytes=bytes+storage_size(eh%n_band    )
            bytes=bytes+storage_size(eh%basis_index_shift)*size(eh%basis_index_shift)
            do iatom=1,eh%n_atom
                bytes=bytes+storage_size(eh%atom(iatom)%n_basis      )
                bytes=bytes+storage_size(eh%atom(iatom)%basis_l      )*size(eh%atom(iatom)%basis_l      )
                bytes=bytes+storage_size(eh%atom(iatom)%basis_m      )*size(eh%atom(iatom)%basis_m      )
                bytes=bytes+storage_size(eh%atom(iatom)%basis_fn     )*size(eh%atom(iatom)%basis_fn     )
                bytes=bytes+storage_size(eh%atom(iatom)%basis_cutoff )*size(eh%atom(iatom)%basis_cutoff )
            enddo
            do ipair=1,eh%n_pair
                bytes=bytes+storage_size(eh%pair(ipair)%a1            )
                bytes=bytes+storage_size(eh%pair(ipair)%a2            )
                bytes=bytes+storage_size(eh%pair(ipair)%nb1           )
                bytes=bytes+storage_size(eh%pair(ipair)%nb2           )
                bytes=bytes+storage_size(eh%pair(ipair)%n_triplet_ham )
                bytes=bytes+storage_size(eh%pair(ipair)%n_triplet_ovl )
                bytes=bytes+storage_size(eh%pair(ipair)%v             )*size(eh%pair(ipair)%v             )
                bytes=bytes+storage_size(eh%pair(ipair)%lv            )*size(eh%pair(ipair)%lv            )
                bytes=bytes+storage_size(eh%pair(ipair)%overlap       )*size(eh%pair(ipair)%overlap       )
                bytes=bytes+storage_size(eh%pair(ipair)%hamiltonian   )*size(eh%pair(ipair)%hamiltonian   )
                if ( eh%pair(ipair)%n_triplet_ham .gt. 0 ) then
                    bytes=bytes+storage_size(eh%pair(ipair)%triplet_ham_ind )*size(eh%pair(ipair)%triplet_ham_ind )
                    bytes=bytes+storage_size(eh%pair(ipair)%triplet_ham_v   )*size(eh%pair(ipair)%triplet_ham_v   )
                    bytes=bytes+storage_size(eh%pair(ipair)%triplet_ham_lv  )*size(eh%pair(ipair)%triplet_ham_lv  )
                    bytes=bytes+storage_size(eh%pair(ipair)%dHdtau          )*size(eh%pair(ipair)%dHdtau          )
                endif
                if ( eh%pair(ipair)%n_triplet_ovl .gt. 0 ) then
                    bytes=bytes+storage_size(eh%pair(ipair)%dOdtau          )*size(eh%pair(ipair)%dOdtau          )
                endif
            enddo
            bytes=bytes/8
        else
            bytes=0_i8
        endif

        ! Tell all ranks how large it is
        size_packed=int(bytes,i4)
        call mw%bcast(size_packed,from=readrank)

        ! Put the timing here to be synced across ranks
        if ( verbosity .gt. 0 ) then
            t1=walltime()
            write(lo_iou,*) '... read hamiltonian and overlap (',tochar(t1-t0),'s)'
            t0=t1
        endif

        ! Space for communication buffer
        call mem%allocate(buf,size_packed,persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
        ! Pack the hamiltonian into the buffer
        if ( mw%r .eq. readrank ) then
            pos=0
            call mw%pack(eh%n_atom            ,buf,pos)
            call mw%pack(eh%n_electron        ,buf,pos)
            call mw%pack(eh%n_spin            ,buf,pos)
            call mw%pack(eh%n_basis           ,buf,pos)
            call mw%pack(eh%n_pair            ,buf,pos)
            call mw%pack(eh%n_band            ,buf,pos)
            call mw%pack(eh%basis_index_shift ,buf,pos)
            do iatom=1,eh%n_atom
                call mw%pack(eh%atom(iatom)%n_basis      ,buf,pos)
                call mw%pack(eh%atom(iatom)%basis_l      ,buf,pos)
                call mw%pack(eh%atom(iatom)%basis_m      ,buf,pos)
                call mw%pack(eh%atom(iatom)%basis_fn     ,buf,pos)
                call mw%pack(eh%atom(iatom)%basis_cutoff ,buf,pos)
            enddo
            do ipair=1,eh%n_pair
                call mw%pack(eh%pair(ipair)%a1            ,buf,pos)
                call mw%pack(eh%pair(ipair)%a2            ,buf,pos)
                call mw%pack(eh%pair(ipair)%nb1           ,buf,pos)
                call mw%pack(eh%pair(ipair)%nb2           ,buf,pos)
                call mw%pack(eh%pair(ipair)%n_triplet_ham ,buf,pos)
                call mw%pack(eh%pair(ipair)%n_triplet_ovl ,buf,pos)
                call mw%pack(eh%pair(ipair)%v             ,buf,pos)
                call mw%pack(eh%pair(ipair)%lv            ,buf,pos)
                call mw%pack(eh%pair(ipair)%overlap       ,buf,pos)
                call mw%pack(eh%pair(ipair)%hamiltonian   ,buf,pos)
                if ( eh%pair(ipair)%n_triplet_ham .gt. 0 ) then
                    call mw%pack(eh%pair(ipair)%triplet_ham_ind ,buf,pos)
                    call mw%pack(eh%pair(ipair)%triplet_ham_v   ,buf,pos)
                    call mw%pack(eh%pair(ipair)%triplet_ham_lv  ,buf,pos)
                    call mw%pack(eh%pair(ipair)%dHdtau          ,buf,pos)
                endif
                if ( eh%pair(ipair)%n_triplet_ovl .gt. 0 ) then
                    call mw%pack(eh%pair(ipair)%dOdtau          ,buf,pos)
                endif
            enddo
        endif
        ! Send it to everyone
        call mw%bcast(buf,from=readrank)

        if ( verbosity .gt. 0 ) then
            t1=walltime()
            write(lo_iou,*) '... packed and communicated (',tochar(t1-t0),'s)'
            t0=t1
        endif

        ! Then unpack it everywhere
        if ( mw%r .ne. readrank ) then
            pos=0
            call mw%unpack(eh%n_atom            ,buf,pos)
            call mw%unpack(eh%n_electron        ,buf,pos)
            call mw%unpack(eh%n_spin            ,buf,pos)
            call mw%unpack(eh%n_basis           ,buf,pos)
            call mw%unpack(eh%n_pair            ,buf,pos)
            call mw%unpack(eh%n_band            ,buf,pos)
            allocate(eh%basis_index_shift(eh%n_atom))
            call mw%unpack(eh%basis_index_shift ,buf,pos)
            allocate(eh%atom(eh%n_atom))
            do iatom=1,eh%n_atom
                call mw%unpack(eh%atom(iatom)%n_basis      ,buf,pos)
                allocate(eh%atom(iatom)%basis_l      (eh%atom(iatom)%n_basis))
                allocate(eh%atom(iatom)%basis_m      (eh%atom(iatom)%n_basis))
                allocate(eh%atom(iatom)%basis_fn     (eh%atom(iatom)%n_basis))
                allocate(eh%atom(iatom)%basis_cutoff (eh%atom(iatom)%n_basis))
                call mw%unpack(eh%atom(iatom)%basis_l      ,buf,pos)
                call mw%unpack(eh%atom(iatom)%basis_m      ,buf,pos)
                call mw%unpack(eh%atom(iatom)%basis_fn     ,buf,pos)
                call mw%unpack(eh%atom(iatom)%basis_cutoff ,buf,pos)
            enddo
            allocate(eh%pair(eh%n_pair))
            do ipair=1,eh%n_pair
                call mw%unpack(eh%pair(ipair)%a1            ,buf,pos)
                call mw%unpack(eh%pair(ipair)%a2            ,buf,pos)
                call mw%unpack(eh%pair(ipair)%nb1           ,buf,pos)
                call mw%unpack(eh%pair(ipair)%nb2           ,buf,pos)
                call mw%unpack(eh%pair(ipair)%n_triplet_ham ,buf,pos)
                call mw%unpack(eh%pair(ipair)%n_triplet_ovl ,buf,pos)
                call mw%unpack(eh%pair(ipair)%v             ,buf,pos)
                call mw%unpack(eh%pair(ipair)%lv            ,buf,pos)
                allocate(eh%pair(ipair)%overlap    ( eh%pair(ipair)%nb1,eh%pair(ipair)%nb2          ))
                allocate(eh%pair(ipair)%hamiltonian( eh%pair(ipair)%nb1,eh%pair(ipair)%nb2,eh%n_spin))
                call mw%unpack(eh%pair(ipair)%overlap       ,buf,pos)
                call mw%unpack(eh%pair(ipair)%hamiltonian   ,buf,pos)
                if ( eh%pair(ipair)%n_triplet_ham .gt. 0 ) then
                    allocate(eh%pair(ipair)%triplet_ham_ind (eh%pair(ipair)%n_triplet_ham)  )
                    allocate(eh%pair(ipair)%triplet_ham_v   (3,eh%pair(ipair)%n_triplet_ham)  )
                    allocate(eh%pair(ipair)%triplet_ham_lv  (3,eh%pair(ipair)%n_triplet_ham)  )
                    allocate(eh%pair(ipair)%dHdtau          (eh%pair(ipair)%nb1,eh%pair(ipair)%nb2,3,eh%pair(ipair)%n_triplet_ham,eh%n_spin)  )
                    call mw%unpack(eh%pair(ipair)%triplet_ham_ind ,buf,pos)
                    call mw%unpack(eh%pair(ipair)%triplet_ham_v   ,buf,pos)
                    call mw%unpack(eh%pair(ipair)%triplet_ham_lv  ,buf,pos)
                    call mw%unpack(eh%pair(ipair)%dHdtau          ,buf,pos)
                endif
                if ( eh%pair(ipair)%n_triplet_ovl .gt. 0 ) then
                    allocate(eh%pair(ipair)%dOdtau          (eh%pair(ipair)%nb1,eh%pair(ipair)%nb2,3,eh%pair(ipair)%n_triplet_ovl)  )
                    call mw%unpack(eh%pair(ipair)%dOdtau          ,buf,pos)
                endif
            enddo
        endif

        ! And cleanup
        call mem%deallocate(buf,persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)

        if ( verbosity .gt. 0 ) then
            t1=walltime()
            write(lo_iou,*) '... unpacked (',tochar(t1-t0),'s)'
            t0=t1
        endif
    end block commham
    endif

    ! if ( verbosity .gt. 0 ) then
    !     t1=walltime()
    !     write(*,*) '... read some metadata (',tochar(t1-t0),'s)'
    !     t0=t1
    !     write(*,*) '            n atom:',eh%n_atom
    !     write(*,*) '        n basis fn:',eh%n_basis
    !     write(*,*) '        n electron:',eh%n_electron
    !     write(*,*) '            n pair:',eh%n_pair
    !     write(*,*) '            n band:',eh%n_band
    !     do i=1,eh%n_atom
    !         write(*,*) ' atom',tochar(i,-3),' n_basis: ',tochar(eh%atom(i)%n_basis),' offset: ',tochar(eh%basis_index_shift(i))
    !         j=min(40,eh%atom(i)%n_basis)
    !         if ( j .lt. eh%atom(i)%n_basis ) then
    !             opf="(1X,A,"//tochar(j)//"(1X,I2),' ...')"
    !         else
    !             opf="(1X,A,"//tochar(j)//"(1X,I2))"
    !         endif
    !         write(*,opf) 'l:',eh%atom(i)%basis_l(1:j)
    !         write(*,opf) 'm:',eh%atom(i)%basis_m(1:j)
    !         write(*,opf) 'i:',eh%atom(i)%basis_fn(1:j)
    !     enddo
    ! endif

    ! Sort basis functions into groups of constant l
    sortintogroups: block
        integer, dimension(:,:), allocatable :: dj1,dj2
        integer, dimension(:), allocatable :: di1
        integer :: a1,i,j,k,l


        do a1=1,eh%n_atom
            call mem%allocate(dj1,[2,eh%atom(a1)%n_basis],persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
            dj1=0
            do i=1,eh%atom(a1)%n_basis
                dj1(:,i)=[ eh%atom(a1)%basis_fn(i), eh%atom(a1)%basis_l(i)]
            enddo
            call lo_return_unique(dj1,dj2,mem)
            eh%atom(a1)%n_basis_groups_on_atom=size(dj2,2)
            allocate( eh%atom(a1)%basis_group(2,eh%atom(a1)%n_basis_groups_on_atom) )
            allocate( eh%atom(a1)%basis_group_l(eh%atom(a1)%n_basis_groups_on_atom) )
            eh%atom(a1)%basis_group=0
            eh%atom(a1)%basis_group_l=0

            ! Get start and stop index of each group
            call mem%allocate(di1,eh%atom(a1)%n_basis,persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
            di1=0
            il1: do i=1,eh%atom(a1)%n_basis
                do j=1,size(dj2,2)
                    if ( sum(abs(dj1(:,i)-dj2(:,j))) .eq. 0 ) then
                        di1(i)=j
                        cycle il1
                    endif
                enddo
            enddo il1
            eh%atom(a1)%basis_group(1,1)=1
            do i=1,eh%atom(a1)%n_basis-1
                if ( di1(i) .ne. di1(i+1) ) then
                    ! new group
                    eh%atom(a1)%basis_group(2,di1(i))=i
                    eh%atom(a1)%basis_group(1,di1(i)+1)=i+1
                endif
            enddo
            eh%atom(a1)%basis_group(2,eh%atom(a1)%n_basis_groups_on_atom)=eh%atom(a1)%n_basis

            ! Stow away l quantum number per group
            do i=1,eh%atom(a1)%n_basis_groups_on_atom
                eh%atom(a1)%basis_group_l(i)=dj2(2,i)
            enddo

            ! Check that I got it right
            do i=1,eh%atom(a1)%n_basis_groups_on_atom
                k=0
                do j=eh%atom(a1)%basis_group(1,i),eh%atom(a1)%basis_group(2,i)
                    k=k+1
                enddo
                l=eh%atom(a1)%basis_group_l(i)
                if ( k .ne. 2*l+1 ) then
                    call lo_stop_gracefully(['Clearly I can not count'],lo_exitcode_symmetry,__FILE__,__LINE__,mw%comm)
                endif
            enddo

            ! And cleanup for the next atom
            call mem%deallocate(dj1,persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
            call mem%deallocate(dj2,persistent=.true. ,scalable=.false.,file=__FILE__,line=__LINE__)
            call mem%deallocate(di1,persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
        enddo

        if ( verbosity .gt. 0 ) then
            t1=walltime()
            write(lo_iou,*) '... sorted out basis function indexing (',tochar(t1-t0),'s)'
            t0=t1
        endif
    end block sortintogroups

    ! Make some extra intermediate space for transforms, if applicable.
    extraspace: block
        real(r8), dimension(:,:), allocatable :: dr,drh
        real(r8), dimension(3) :: v0
        integer :: ipair,ctr,itrip,i,j

        ! Make some additional workspace we will need when evaluating matrix elements.
        do ipair=1,eh%n_pair
            if ( eh%pair(ipair)%n_triplet_ham .gt. 0 ) then
                allocate(eh%pair(ipair)%dHdqs(eh%n_basis,eh%n_basis,eh%n_spin))
                allocate(eh%pair(ipair)%triplet_ham_global_ind(eh%pair(ipair)%n_triplet_ham) )
                eh%pair(ipair)%dHdqs=0.0_r8
                eh%pair(ipair)%triplet_ham_global_ind=0
            endif
            if ( eh%pair(ipair)%n_triplet_ovl .gt. 0 ) then
                allocate(eh%pair(ipair)%dOdqs(eh%n_basis,eh%n_basis))
                eh%pair(ipair)%dOdqs=0.0_r8
                eh%pair(ipair)%triplet_ovl_global_ind=0
            endif
        enddo

        ! Get a list of all the possible atoms that could be in Hamiltonian triplets.
        ctr=0
        do ipair=1,eh%n_pair
            ctr=ctr+eh%pair(ipair)%n_triplet_ham
        enddo

        if ( ctr .gt. 0 ) then
            call mem%allocate(dr,[3,ctr],persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
            dr=0.0_r8
            ctr=0
            do ipair=1,eh%n_pair
            do itrip=1,eh%pair(ipair)%n_triplet_ham
                ctr=ctr+1
                dr(:,ctr)=p%rcart(:,eh%pair(ipair)%a1)+eh%pair(ipair)%triplet_ham_v(:,itrip)
            enddo
            enddo
            call lo_return_unique(dr,drh,mem)
            call mem%deallocate(dr, persistent=.false.,scalable=.false.,file=__FILE__,line=__LINE__)
        endif

        ! Now sort out the global indices to triplet perturbations
        do ipair=1,eh%n_pair
            do itrip=1,eh%pair(ipair)%n_triplet_ham
                v0=p%rcart(:,eh%pair(ipair)%a1)+eh%pair(ipair)%triplet_ham_v(:,itrip)
                j=0
                do i=1,size(drh,2)
                    if ( lo_sqnorm(v0-drh(:,i)) .lt. lo_sqtol ) then
                        j=i
                        exit
                    endif
                enddo
                if ( j .gt. 0 ) then
                    eh%pair(ipair)%triplet_ham_global_ind(itrip)=j
                else
                    call lo_stop_gracefully(['Clearly I am not a smart man'],lo_exitcode_symmetry,__FILE__,__LINE__,mw%comm)
                endif
            enddo
            if ( eh%pair(ipair)%n_triplet_ovl .gt. 0 ) then
                v0=p%rcart(:,eh%pair(ipair)%a1)
                j=0
                do i=1,size(drh,2)
                    if ( lo_sqnorm(v0-drh(:,i)) .lt. lo_sqtol ) then
                        j=i
                        exit
                    endif
                enddo
                if ( j .gt. 0 ) then
                    eh%pair(ipair)%triplet_ovl_global_ind(1)=j
                else
                    call lo_stop_gracefully(['Clearly I am not a smart man'],lo_exitcode_symmetry,__FILE__,__LINE__,mw%comm)
                endif

                v0=p%rcart(:,eh%pair(ipair)%a1)+eh%pair(ipair)%v
                j=0
                do i=1,size(drh,2)
                    if ( lo_sqnorm(v0-drh(:,i)) .lt. lo_sqtol ) then
                        j=i
                        exit
                    endif
                enddo
                if ( j .gt. 0 ) then
                    eh%pair(ipair)%triplet_ovl_global_ind(2)=j
                else
                    call lo_stop_gracefully(['Clearly I am not a smart man'],lo_exitcode_symmetry,__FILE__,__LINE__,mw%comm)
                endif
            endif

        enddo

        if ( allocated(drh) ) call mem%deallocate(drh,persistent=.true. ,scalable=.false.,file=__FILE__,line=__LINE__)

        if ( verbosity .gt. 0 ) then
            t1=walltime()
            write(lo_iou,*) '... sorted out padded information (',tochar(t1-t0),'s)'
            t0=t1
        endif
    end block extraspace

    if ( verbosity .gt. 0 ) then
        write(lo_iou,*) 'Read electronic Hamiltonian (',tochar(walltime()-timer),'s)'
    endif
end subroutine

!> write hamiltonian to file
subroutine write_to_hdf5(eh,filename)
    !> hamiltonian
    class(lo_effective_hamiltonian), intent(in) :: eh
    !> filename
    character(len=*), intent(in) :: filename

    type(lo_hdf5_helper) :: h5
    real(r8), dimension(:,:), allocatable :: dr
    integer :: i

    call h5%init(__FILE__,__LINE__)
    call h5%open_file('write',trim(filename))

    call h5%store_attribute(eh%n_atom,h5%file_id,'n_atom')
    call h5%store_attribute(eh%n_electron,h5%file_id,'n_electron')
    call h5%store_attribute(eh%n_spin,h5%file_id,'n_spin')
    call h5%store_attribute(eh%n_basis,h5%file_id,'n_basis')
    call h5%store_attribute(eh%n_band,h5%file_id,'n_band')
    call h5%store_attribute(eh%n_pair,h5%file_id,'n_pair')
    call h5%store_data(eh%basis_index_shift,h5%file_id,'basis_index_shift',enhet='index')

    ! Not sure if this is always needed, but does not hurt I suppose.
    do i=1,eh%n_atom
        call h5%open_group('write','basis_atom_'//tochar(i))
        call h5%store_data(eh%atom(i)%basis_l,h5%group_id,'basis_l',enhet='index')
        call h5%store_data(eh%atom(i)%basis_m,h5%group_id,'basis_m',enhet='index')
        call h5%store_data(eh%atom(i)%basis_fn,h5%group_id,'basis_fn',enhet='index')
        call h5%store_data(eh%atom(i)%basis_cutoff,h5%group_id,'basis_cutoff',enhet='Bohr')
        call h5%close_group()
    enddo

    allocate(dr(3,eh%n_pair))
    do i=1,eh%n_pair
        dr(:,i)=eh%pair(i)%v
    enddo
    call h5%store_data(dr,h5%file_id,'pair_vectors',enhet='bohr')
    do i=1,eh%n_pair
        dr(:,i)=eh%pair(i)%lv
    enddo
    call h5%store_data(dr,h5%file_id,'lattice_vectors',enhet='bohr')
    deallocate(dr)

    do i=1,eh%n_pair
        call h5%open_group('write','pair_'//tochar(i))
        ! Storing normal pair things
        call h5%store_attribute(eh%pair(i)%a1,h5%group_id,'atom1')
        call h5%store_attribute(eh%pair(i)%a2,h5%group_id,'atom2')
        call h5%store_attribute(eh%pair(i)%nb1,h5%group_id,'nb1')
        call h5%store_attribute(eh%pair(i)%nb2,h5%group_id,'nb2')
        call h5%store_data(eh%pair(i)%overlap,h5%group_id,'overlap',enhet='dimensionless')
        call h5%store_data(eh%pair(i)%hamiltonian,h5%group_id,'hamiltonian',enhet='Hartree')

        ! Triplet expansion things
        call h5%store_attribute(eh%pair(i)%n_triplet_ham,h5%group_id,'ntriplet_ham')
        call h5%store_attribute(eh%pair(i)%n_triplet_ovl,h5%group_id,'ntriplet_ovl')
        if ( eh%pair(i)%n_triplet_ham .gt. 0 ) then
            call h5%store_data(eh%pair(i)%triplet_ham_ind,h5%group_id,'triplet_ham_ind',enhet='index')
            call h5%store_data(eh%pair(i)%triplet_ham_v,h5%group_id,'triplet_ham_v',enhet='bohr')
            call h5%store_data(eh%pair(i)%triplet_ham_lv,h5%group_id,'triplet_ham_lv',enhet='bohr')
            call h5%store_data(eh%pair(i)%dHdtau,h5%group_id,'dHdtau',enhet='Hartree/bohr')
        endif
        if ( eh%pair(i)%n_triplet_ovl .gt. 0 ) then
            call h5%store_data(eh%pair(i)%dOdtau,h5%group_id,'dOdtau',enhet='1/bohr')
        endif
    call h5%close_group()
    enddo

    call h5%close_file()
    call h5%destroy(__FILE__,__LINE__)
end subroutine

! !> return the Hamiltonian
! subroutine ham_and_ovl(eh,kvec,hamiltonian,overlap)
!     !> AIMS hamiltonian
!     class(lo_effective_hamiltonian), intent(in) :: eh
!     !> k-vector
!     real(r8), dimension(3), intent(in) :: kvec
!     !> hamiltonian
!     complex(r8), dimension(:,:,:), intent(out) :: hamiltonian
!     !> overlap
!     complex(r8), dimension(:,:), intent(out) :: overlap
! 
!     ! Fourier transform the Hamiltonian and overlap
!     complex(r8) :: expikr
!     real(r8), dimension(3) :: lv
!     real(r8) :: kdotr
!     integer :: a1,a2,i1,i2,j1,j2,ispin
!     integer :: ipair
! 
!     overlap=0.0_r8
!     hamiltonian=0.0_r8
!     do ipair=1,eh%n_pair
!         a1=eh%pair(ipair)%a1
!         a2=eh%pair(ipair)%a2
!         lv=eh%pair(ipair)%lv
!         kdotr=dot_product(lv,kvec)*lo_twopi
!         expikr=cmplx(cos(kdotr),sin(kdotr),r8)
!         ! Where should it be added?
!         i1=eh%basis_index_shift(a1)+1
!         i2=eh%basis_index_shift(a1)+eh%atom(a1)%n_basis
!         j1=eh%basis_index_shift(a2)+1
!         j2=eh%basis_index_shift(a2)+eh%atom(a2)%n_basis
!         ! first overlap
!         overlap(i1:i2,j1:j2)=overlap(i1:i2,j1:j2)+eh%pair(ipair)%overlap*expikr
!         do ispin=1,eh%n_spin
!             hamiltonian(i1:i2,j1:j2,ispin)=hamiltonian(i1:i2,j1:j2,ispin)+eh%pair(ipair)%hamiltonian(:,:,ispin)*expikr
!         enddo
!     enddo
! end subroutine

!> size in memory, in bytes
function effham_size_in_mem(eh) result(mem)
    !> pair in Hamiltonian
    class(lo_effective_hamiltonian), intent(in) :: eh
    !> memory in bytes
    integer(i8) :: mem

    integer :: i

    mem=0
    mem=mem+storage_size(eh)
    if ( allocated(eh%basis_index_shift) ) mem=mem+storage_size(eh%basis_index_shift)*size(eh%basis_index_shift)
    if ( allocated(eh%atom) ) then
        do i=1,size(eh%atom)
            mem=mem+storage_size(eh%atom(i))
            if ( allocated(eh%atom(i)%basis_l       ) ) mem=mem+storage_size(eh%atom(i)%basis_l       )*size(eh%atom(i)%basis_l       )
            if ( allocated(eh%atom(i)%basis_m       ) ) mem=mem+storage_size(eh%atom(i)%basis_m       )*size(eh%atom(i)%basis_m       )
            if ( allocated(eh%atom(i)%basis_fn      ) ) mem=mem+storage_size(eh%atom(i)%basis_fn      )*size(eh%atom(i)%basis_fn      )
            if ( allocated(eh%atom(i)%basis_cutoff  ) ) mem=mem+storage_size(eh%atom(i)%basis_cutoff  )*size(eh%atom(i)%basis_cutoff  )
            if ( allocated(eh%atom(i)%basis_group_l ) ) mem=mem+storage_size(eh%atom(i)%basis_group_l )*size(eh%atom(i)%basis_group_l )
            if ( allocated(eh%atom(i)%basis_group   ) ) mem=mem+storage_size(eh%atom(i)%basis_group   )*size(eh%atom(i)%basis_group   )
        enddo
    endif
    if ( allocated(eh%pair) ) then
        do i=1,size(eh%pair)
            mem=mem+storage_size(eh%pair(i))
            if ( allocated(eh%pair(i)%hamiltonian     ) ) mem=mem+storage_size(eh%pair(i)%hamiltonian     )*size(eh%pair(i)%hamiltonian     )
            if ( allocated(eh%pair(i)%overlap         ) ) mem=mem+storage_size(eh%pair(i)%overlap         )*size(eh%pair(i)%overlap         )
            if ( allocated(eh%pair(i)%triplet_ham_ind ) ) mem=mem+storage_size(eh%pair(i)%triplet_ham_ind )*size(eh%pair(i)%triplet_ham_ind )
            if ( allocated(eh%pair(i)%triplet_ham_v   ) ) mem=mem+storage_size(eh%pair(i)%triplet_ham_v   )*size(eh%pair(i)%triplet_ham_v   )
            if ( allocated(eh%pair(i)%triplet_ham_lv  ) ) mem=mem+storage_size(eh%pair(i)%triplet_ham_lv  )*size(eh%pair(i)%triplet_ham_lv  )
            if ( allocated(eh%pair(i)%dHdtau          ) ) mem=mem+storage_size(eh%pair(i)%dHdtau          )*size(eh%pair(i)%dHdtau          )
            if ( allocated(eh%pair(i)%dOdtau          ) ) mem=mem+storage_size(eh%pair(i)%dOdtau          )*size(eh%pair(i)%dOdtau          )
            if ( allocated(eh%pair(i)%dHdqs           ) ) mem=mem+storage_size(eh%pair(i)%dHdqs           )*size(eh%pair(i)%dHdqs           )
            if ( allocated(eh%pair(i)%dOdqs           ) ) mem=mem+storage_size(eh%pair(i)%dOdqs           )*size(eh%pair(i)%dOdqs           )
        enddo
    endif
    mem=mem/8
end function

!> return the rotation matrix for a symmetry operation
subroutine kspace_rotation_matrix(eh,op,p,kvector,rotationmatrix)
    !> basis set information
    class(lo_effective_hamiltonian), intent(in) :: eh
    !> symmetry operation
    type(lo_spacegroup_operation), intent(in) :: op
    !> crystal structure
    type(lo_crystalstructure), intent(in) :: p
    !> kpoint (in fractional Cartesian coordinates)
    real(r8), dimension(3), intent(in) :: kvector
    !> rotation matrix
    complex(r8), dimension(:,:), intent(out) :: rotationmatrix

    real(r8), dimension(3,3) :: m0
    real(r8), dimension( 0:0, 0:0) :: rm0
    real(r8), dimension(-1:1,-1:1) :: rm1
    real(r8), dimension(-2:2,-2:2) :: rm2
    real(r8), dimension(-3:3,-3:3) :: rm3
    real(r8), dimension(-4:4,-4:4) :: rm4
    real(r8), dimension(-5:5,-5:5) :: rm5
    real(r8), dimension(3) :: v0,v1
    real(r8) :: arg
    complex(r8) :: phasefactor
    integer :: a1,a2,i1,i2,j1,j2,i,l

    ! Indexing of large matrix should be (new,old)
    ! Such that new = (new,old)*old
    ! If that makes any sense.
    m0=op%im
    rotationmatrix=0.0_r8
    do a1=1,eh%n_atom
        a2=op%fmap(a1)
        do i=1,eh%atom(a1)%n_basis_groups_on_atom
            ! Sort out where we are
            l =eh%atom(a1)%basis_group_l(i)
            j1=eh%atom(a1)%basis_group(1,i)+eh%basis_index_shift(a1)
            j2=eh%atom(a1)%basis_group(2,i)+eh%basis_index_shift(a1)
            i1=eh%atom(a2)%basis_group(1,i)+eh%basis_index_shift(a2)
            i2=eh%atom(a2)%basis_group(2,i)+eh%basis_index_shift(a2)
            ! Get the phase factor. This is the same as from Maradudin.
            ! This actually works, tested brute force on very accurate
            ! eigenvectors, as opposed to the thingy in the AIMS manual.
            v0=kvector*lo_twopi
            v1=matmul(op%im,p%rcart(:,a2))-p%rcart(:,a1)
            arg=dot_product(v0,v1)
            phasefactor=cmplx(cos(arg),sin(arg),r8)

            select case(l)
            case(0)
                call realspace_spherical_harmonic_rotation_matrix(m0,0,rm0)
                rotationmatrix(i1:i2,j1:j2)=rm0(0:0,0:0)*phasefactor
            case(1)
                call realspace_spherical_harmonic_rotation_matrix(m0,1,rm1)
                rotationmatrix(i1:i2,j1:j2)=rm1(-1:1,-1:1)*phasefactor
            case(2)
                call realspace_spherical_harmonic_rotation_matrix(m0,2,rm2)
                rotationmatrix(i1:i2,j1:j2)=rm2(-2:2,-2:2)*phasefactor
            case(3)
                call realspace_spherical_harmonic_rotation_matrix(m0,3,rm3)
                rotationmatrix(i1:i2,j1:j2)=rm3(-3:3,-3:3)*phasefactor
            case(4)
                call realspace_spherical_harmonic_rotation_matrix(m0,4,rm4)
                rotationmatrix(i1:i2,j1:j2)=rm4(-4:4,-4:4)*phasefactor
            case(5)
                call realspace_spherical_harmonic_rotation_matrix(m0,5,rm5)
                rotationmatrix(i1:i2,j1:j2)=rm5(-5:5,-5:5)*phasefactor
            case default
                call lo_stop_gracefully(['Current max l is 5, nag on me to fix higher'],lo_exitcode_param,__FILE__,__LINE__)
            end select
        enddo
    enddo
end subroutine

!> realspace spherical harmonic rotation matrix
subroutine realspace_spherical_harmonic_rotation_matrix(m,l,rotm)
    !> normal 3x3 rotation matrix
    real(r8), dimension(3,3), intent(in) :: m
    !> l number
    integer, intent(in) :: l
    !> rotation matrix
    real(r8), dimension(-l:l,-l:l), intent(out) :: rotm

    real(r8) :: al,be,gm
    real(r8), dimension(3,3) :: mm
    logical :: inversion

    !@TODO Find the thingy where I had this created a bit nicer, with much less temporary variables and fewer leafs.
    !@TODO take an actual operation as input?
    !@TODO store inversion and angles already in the symmetry operation

    ! check wether it's a proper or improper rotation
    if ( lo_determ(m) .lt. 0.0_r8 ) then
        mm=-m
        inversion=.true.
    else
        mm=m
        inversion=.false.
    endif

    ! grab the Euler angles for the proper rotation.
    ! this is some sort of convention. Not sure which.
    ! pretty sure this can be done in a more elegant way.
    if ( ( abs(mm(3,1)) .gt. lo_sqtol ) .or. ( abs(mm(3,2)) .gt. lo_sqtol ) ) then
        al = atan2(mm(3,2), mm(3,1))
        if ( al .lt. 0.0_r8 ) al=al+lo_twopi
        if ( abs(mm(3,1)) .gt. abs(mm(3,2)) ) then
            be = atan2(mm(3,1)/cos(al),mm(3,3))
        else
            be = atan2(mm(3,2)/sin(al),mm(3,3))
        endif
        gm = atan2(mm(2,3),-mm(1,3))
        if ( gm .lt. 0.0_r8 ) gm=gm+lo_twopi
    else
        al = atan2(mm(1,2),mm(1,1))
        if ( al .lt. 0.0_r8 ) al=al+lo_twopi
        if (mm(3,3) > 0.0_r8 ) then
            be=0.0_r8
            gm=0.0_r8
        else
            be=lo_pi
            gm=lo_pi
        endif
    endif

    ! different for different l numbers. All tabulated neatly, up to l=5 for now. Not sure how high AIMS
    ! can go. Can fix more if needed, it's just a little annoying.
    getrm: block
        ! a bunch of parameters and shorthand to make it a little faster.
        real(r8) :: sa,sb,sg,ca,cb,cg,s2a,s2b,s2g,c2a,c2b,c2g,sa2,sb2,sg2,ca2,cb2,cg2
        real(r8) :: ca2sq,cb2sq,cg2sq,sa2sq,sb2sq,sg2sq
        real(r8) :: capg,camg,cbpg,cbmg,capb,camb,sapg,samg,sbpg,sbmg,sapb,samb
        real(r8), parameter :: half=0.5_r8,quarter=0.25_r8 !,threequarter=0.75_r8
        real(r8), parameter :: eigth=0.125_r8,inv16=1.0_r8/16.0_r8,inv32=1.0_r8/32.0_r8
        real(r8), parameter :: sqrt3=1.7320508075688772935_r8,sqrt5=2.2360679774997896964_r8,sqrt7=2.6457513110645905905_r8
        real(r8), parameter :: sqrt15=3.872983346207416885_r8,sqrt5o2=1.581138830084189666_r8,sqrt3o2=1.224744871391589049_r8
        real(r8), parameter :: sqrt35=5.916079783099616042_r8,invsqrt32=0.17677669529663688110_r8,inv64=0.015625_r8
        real(r8), parameter :: sqrt35o2=4.1833001326703777399_r8,sqrt7o2=1.8708286933869706928_r8,inv128=0.0078125_r8
        real(r8), parameter :: invsqrt128=0.088388347648318440550_r8,invsqrt2048=1.0_r8/sqrt(2048.0_r8)
        real(r8), parameter :: invsqrt512=1.0_r8/sqrt(512.0_r8),inv256=1.0_r8/256.0_r8,invsqrt2=1.0_r8/sqrt(2.0_r8)
        real(r8), parameter :: sqrt105=sqrt(105.0_r8),sqrt105o2=sqrt(105.0_r8/2.0_r8),sqrt15o2=sqrt(15.0_r8/2.0_r8)
        real(r8), parameter :: sqrt21=sqrt(21.0_r8),sqrt21o2=sqrt(21.0_r8/2.0_r8)
        sa=sin(al)
        sb=sin(be)
        sg=sin(gm)
        ca=cos(al)
        cb=cos(be)
        cg=cos(gm)
        s2a=sin(2.0_r8*al)
        s2b=sin(2.0_r8*be)
        s2g=sin(2.0_r8*gm)
        c2a=cos(2.0_r8*al)
        c2b=cos(2.0_r8*be)
        c2g=cos(2.0_r8*gm)
        sa2=sin(0.5_r8*al)
        sb2=sin(0.5_r8*be)
        sg2=sin(0.5_r8*gm)
        ca2=cos(0.5_r8*al)
        cb2=cos(0.5_r8*be)
        cg2=cos(0.5_r8*gm)
        ca2sq=cos(al*0.5_r8)**2
        cb2sq=cos(be*0.5_r8)**2
        cg2sq=cos(gm*0.5_r8)**2
        sa2sq=sin(al*0.5_r8)**2
        sb2sq=sin(be*0.5_r8)**2
        sg2sq=sin(gm*0.5_r8)**2
        capg=cos(al+gm)
        camg=cos(al-gm)
        cbpg=cos(be+gm)
        cbmg=cos(be-gm)
        capb=cos(al+be)
        camb=cos(al-be)
        sapg=sin(al+gm)
        samg=sin(al-gm)
        sbpg=sin(be+gm)
        sbmg=sin(be-gm)
        sapb=sin(al+be)
        samb=sin(al-be)

        rotm=lo_huge
        select case(l)
        case(0) ! simple enough
            rotm=1.0_r8
        case(1) ! 3x3 thingy
            rotm(-1,-1)=capg*cb2sq + camg*sb2sq
            rotm( 0,-1)=sb*sg
            rotm( 1,-1)=cb2sq*sapg + samg*sb2sq
            rotm(-1, 0)=sa*sb
            rotm( 0, 0)=cb
            rotm( 1, 0)=-(ca*sb)
            rotm(-1, 1)=-(cb2sq*sapg) + samg*sb2sq
            rotm( 0, 1)=cg*sb
            rotm( 1, 1)=capg*cb2sq - camg*sb2sq
        case(2) ! 5x5 thingy
            rotm(-2,-2)=c2a*c2g*cb - (3 + c2b)*quarter*s2a*s2g
            rotm(-1,-2)=(-(c2g*ca) + cb*s2g*sa)*sb
            rotm(0,-2)=-(cg*sb**2*sg*sqrt3)
            rotm(1,-2)=-((ca*cb*s2g + c2g*sa)*sb)
            rotm(2,-2)=-(c2g*cb*s2a) - c2a*(3 + c2b)*quarter*s2g
            rotm(-2,-1)=sb*(c2a*cg - 2*ca*cb*sa*sg)
            rotm(-1,-1)=ca*cb*cg - c2b*sa*sg
            rotm(0,-1)=cb*sb*sg*sqrt3
            rotm(1,-1)=cb*cg*sa + c2b*ca*sg
            rotm(2,-1)=-(cg*s2a*sb) - c2a*half*s2b*sg
            rotm(-2,0)=ca*sa*sb**2*sqrt3
            rotm(-1,0)=cb*sa*sb*sqrt3
            rotm(0,0)=(1 + 3*c2b)*quarter
            rotm(1,0)=-(ca*cb*sb*sqrt3)
            rotm(2,0)=c2a*half*sb**2*sqrt3
            rotm(-2,1)=-(sb*(cb*cg*s2a + c2a*sg))
            rotm(-1,1)=-(c2b*cg*sa) - ca*cb*sg
            rotm(0,1)=cb*cg*sb*sqrt3
            rotm(1,1)=c2b*ca*cg - cb*sa*sg
            rotm(2,1)=-(c2a*cg*half*s2b) + s2a*sb*sg
            rotm(-2,2)=(3 + c2b)*c2g*quarter*s2a + c2a*cb*s2g
            rotm(-1,2)=-((ca*s2g + c2g*cb*sa)*sb)
            rotm(0,2)=c2g*half*sb**2*sqrt3
            rotm(1,2)=sb*(c2g*ca*cb - 2*cg*sa*sg)
            rotm(2,2)=c2a*(3 + c2b)*c2g*quarter - cb*s2a*s2g
        case(3) ! 7x7, getting hairy
            rotm(-3,-3)=sb2**6*Cos(3*(al - gm)) + cb2**6*Cos(3*(al + gm))
            rotm(-2,-3)=sb2*sqrt3o2*(sb*sb2**3*Cos(2*al - 3*gm) - 2*cb2**5*Cos(2*al + 3*gm))
            rotm(-1,-3)=quarter*sb2**2*sqrt15*(sb**2*Cos(al - 3*gm) + 4*cb2**4*Cos(al + 3*gm))
            rotm(0,-3)=half*sb**3*sqrt5o2*Sin(3*gm)
            rotm(1,-3)=quarter*sb2**2*sqrt15*(sb**2*Sin(al - 3*gm) + 4*cb2**4*Sin(al + 3*gm))
            rotm(2,-3)=sb2*sqrt3o2*(-(sb*sb2**3*Sin(2*al - 3*gm)) + 2*cb2**5*Sin(2*al + 3*gm))
            rotm(3,-3)=sb2**6*Sin(3*(al - gm)) + cb2**6*Sin(3*(al + gm))
            rotm(-3,-2)=sb2*sqrt3o2*(-(sb*sb2**3*Cos(3*al - 2*gm)) + 2*cb2**5*Cos(3*al + 2*gm))
            rotm(-2,-2)=-((2 + 3*cb)*sb2**4*Cos(2*(al - gm))) + (-2 + 3*cb)*cb2**4*Cos(2*(al + gm))
            rotm(-1,-2)=-(cb2*sb2*sqrt5o2*((1 + 3*cb)*sb2**2*Cos(al - 2*gm) + (-1 + 3*cb)*cb2**2*Cos(al + 2*gm)))
            rotm(0,-2)=-(cb*cg*sb**2*sg*sqrt15)
            rotm(1,-2)=-(cb2*sb2*sqrt5o2*((1 + 3*cb)*sb2**2*Sin(al - 2*gm) + (-1 + 3*cb)*cb2**2*Sin(al + 2*gm)))
            rotm(2,-2)=(2 + 3*cb)*sb2**4*Sin(2*(al - gm)) + (2 - 3*cb)*cb2**4*Sin(2*(al + gm))
            rotm(3,-2)=sb2*sqrt3o2*(-(sb*sb2**3*Sin(3*al - 2*gm)) + 2*cb2**5*Sin(3*al + 2*gm))
            rotm(-3,-1)=quarter*sb2**2*sqrt15*(sb**2*Cos(3*al - gm) + 4*cb2**4*Cos(3*al + gm))
            rotm(-2,-1)=cb2*sb2*sqrt5o2*((1 + 3*cb)*sb2**2*Cos(2*al - gm) + (-1 + 3*cb)*cb2**2*Cos(2*al + gm))
            rotm(-1,-1)=eigth*((3 + 5*c2b)*ca*cg + (7 - 15*c2b)*cb*sa*sg)
            rotm(0,-1)=eigth*sg*sqrt3o2*(sb + 5*Sin(3*be))
            rotm(1,-1)=eigth*((3 + 5*c2b)*cg*sa + (-7 + 15*c2b)*ca*cb*sg)
            rotm(2,-1)=-(cb2*sb2*sqrt5o2*((1 + 3*cb)*sb2**2*Sin(2*al - gm) + (-1 + 3*cb)*cb2**2*Sin(2*al + gm)))
            rotm(3,-1)=quarter*sb2**2*sqrt15*(sb**2*Sin(3*al - gm) + 4*cb2**4*Sin(3*al + gm))
            rotm(-3,0)=half*sb**3*sqrt5o2*Sin(3*al)
            rotm(-2,0)=ca*cb*sa*sb**2*sqrt15
            rotm(-1,0)=eigth*sa*sqrt3o2*(sb + 5*Sin(3*be))
            rotm(0,0)=eigth*(3*cb + 5*Cos(3*be))
            rotm(1,0)=-(ca*eigth*sqrt3o2*(sb + 5*Sin(3*be)))
            rotm(2,0)=c2a*cb*half*sb**2*sqrt15
            rotm(3,0)=-(half*sb**3*sqrt5o2*Cos(3*al))
            rotm(-3,1)=quarter*sb2**2*sqrt15*(sb**2*Sin(3*al - gm) - 4*cb2**4*Sin(3*al + gm))
            rotm(-2,1)=cb2*sb2*sqrt5o2*((1 + 3*cb)*sb2**2*Sin(2*al - gm) + (1 - 3*cb)*cb2**2*Sin(2*al + gm))
            rotm(-1,1)=inv32*((43 - 45*c2b)*cb*cg*sa - 30*cb**3*cg*sa - 2*(1 + 5*c2b)*ca*sg - 20*ca*cb**2*sg)
            rotm(0,1)=cg*eigth*sqrt3o2*(sb + 5*Sin(3*be))
            rotm(1,1)=inv16*(-2*(3 + 5*c2b)*sa*sg + ca*cg*(cb + 15*Cos(3*be)))
            rotm(2,1)=cb2*sb2*sqrt5o2*((1 + 3*cb)*sb2**2*Cos(2*al - gm) + (1 - 3*cb)*cb2**2*Cos(2*al + gm))
            rotm(3,1)=quarter*sb2**2*sqrt15*(-(sb**2*Cos(3*al - gm)) + 4*cb2**4*Cos(3*al + gm))
            rotm(-3,2)=sb2*sqrt3o2*(sb*sb2**3*Sin(3*al - 2*gm) + 2*cb2**5*Sin(3*al + 2*gm))
            rotm(-2,2)=(2 + 3*cb)*sb2**4*Sin(2*(al - gm)) + (-2 + 3*cb)*cb2**4*Sin(2*(al + gm))
            rotm(-1,2)=cb2*sb2*sqrt5o2*((1 + 3*cb)*sb2**2*Sin(al - 2*gm) + (1 - 3*cb)*cb2**2*Sin(al + 2*gm))
            rotm(0,2)=c2g*cb*half*sb**2*sqrt15
            rotm(1,2)=cb2*sb2*sqrt5o2*(-((1 + 3*cb)*sb2**2*Cos(al - 2*gm)) + (-1 + 3*cb)*cb2**2*Cos(al + 2*gm))
            rotm(2,2)=(2 + 3*cb)*sb2**4*Cos(2*(al - gm)) + (-2 + 3*cb)*cb2**4*Cos(2*(al + gm))
            rotm(3,2)=-(sb2*sqrt3o2*(sb*sb2**3*Cos(3*al - 2*gm) + 2*cb2**5*Cos(3*al + 2*gm)))
            rotm(-3,3)=sb2**6*Sin(3*(al - gm)) - cb2**6*Sin(3*(al + gm))
            rotm(-2,3)=sb2*sqrt3o2*(sb*sb2**3*Sin(2*al - 3*gm) + 2*cb2**5*Sin(2*al + 3*gm))
            rotm(-1,3)=quarter*sb2**2*sqrt15*(sb**2*Sin(al - 3*gm) - 4*cb2**4*Sin(al + 3*gm))
            rotm(0,3)=half*sb**3*sqrt5o2*Cos(3*gm)
            rotm(1,3)=quarter*sb2**2*sqrt15*(-(sb**2*Cos(al - 3*gm)) + 4*cb2**4*Cos(al + 3*gm))
            rotm(2,3)=sb2*sqrt3o2*(sb*sb2**3*Cos(2*al - 3*gm) + 2*cb2**5*Cos(2*al + 3*gm))
            rotm(3,3)=-(sb2**6*Cos(3*(al - gm))) + cb2**6*Cos(3*(al + gm))
        case(4) ! 9x9, getting rough.
            rotm(-4,-4)=eigth*Cos(4*al)*(7*cb + Cos(3*be))*Cos(4*gm) - inv64*(35 + 28*c2b + Cos(4*be))*Sin(4*al)*Sin(4*gm)
            rotm(-3,-4)=invsqrt512*(-2*Cos(3*al)*Cos(4*gm)*(7*sb + 3*Sin(3*be)) + Sin(3*al)*(14*s2b + Sin(4*be))*Sin(4*gm))
            rotm(-2,-4)=eigth*sb**2*sqrt7*(4*c2a*cb*Cos(4*gm) - (3 + c2b)*s2a*Sin(4*gm))
            rotm(-1,-4)=half*sb**3*sqrt7o2*(-(ca*Cos(4*gm)) + cb*sa*Sin(4*gm))
            rotm(0,-4)=-(eigth*sb**4*sqrt35*Sin(4*gm))
            rotm(1,-4)=-(half*sb**3*sqrt7o2*(sa*Cos(4*gm) + ca*cb*Sin(4*gm)))
            rotm(2,-4)=-(eigth*sb**2*sqrt7*(4*cb*s2a*Cos(4*gm) + c2a*(3 + c2b)*Sin(4*gm)))
            rotm(3,-4)=invsqrt2048*(-4*Cos(4*gm)*Sin(3*al)*(7*sb + 3*Sin(3*be)) - 2*Cos(3*al)*(14*s2b + Sin(4*be))*Sin(4*gm))
            rotm(4,-4)=-(eigth*(7*cb + Cos(3*be))*Cos(4*gm)*Sin(4*al)) - inv64*Cos(4*al)*(35 + 28*c2b + Cos(4*be))*Sin(4*gm)
            rotm(-4,-3)=invsqrt2048*(4*Cos(4*al)*Cos(3*gm)*(7*sb + 3*Sin(3*be)) - 2*Sin(4*al)*(14*s2b + Sin(4*be))*Sin(3*gm))
            rotm(-3,-3)=inv16*(Cos(3*al)*(7*cb + 9*Cos(3*be))*Cos(3*gm) - 2*(7*c2b + Cos(4*be))*Sin(3*al)*Sin(3*gm))
            rotm(-2,-3)=eigth*sqrt7o2*(c2a*Cos(3*gm)*(sb - 3*Sin(3*be)) + 8*cb**3*s2a*sb*Sin(3*gm))
            rotm(-1,-3)=quarter*sb**2*sqrt7*(3*ca*cb*Cos(3*gm) - (1 + 2*c2b)*sa*Sin(3*gm))
            rotm(0,-3)=cb*half*sb**3*sqrt35o2*Sin(3*gm)
            rotm(1,-3)=quarter*sb**2*sqrt7*(3*cb*sa*Cos(3*gm) + (1 + 2*c2b)*ca*Sin(3*gm))
            rotm(2,-3)=eigth*sqrt7o2*(s2a*Cos(3*gm)*(-sb + 3*Sin(3*be)) + 8*c2a*cb**3*sb*Sin(3*gm))
            rotm(3,-3)=inv16*((7*cb + 9*Cos(3*be))*Cos(3*gm)*Sin(3*al) + 2*Cos(3*al)*(7*c2b + Cos(4*be))*Sin(3*gm))
            rotm(4,-3)=invsqrt2048*(-4*Cos(3*gm)*Sin(4*al)*(7*sb + 3*Sin(3*be)) - 2*Cos(4*al)*(14*s2b + Sin(4*be))*Sin(3*gm))
            rotm(-4,-2)=eigth*sb**2*sqrt7*(4*c2g*cb*Cos(4*al) - (3 + c2b)*s2g*Sin(4*al))
            rotm(-3,-2)=-(eigth*sqrt7o2*(8*cb**3*s2g*sb*Sin(3*al) + c2g*Cos(3*al)*(sb - 3*Sin(3*be))))
            rotm(-2,-2)=c2a*c2g*eigth*(cb + 7*Cos(3*be)) - inv16*s2a*s2g*(5 + 4*c2b + 7*Cos(4*be))
            rotm(-1,-2)=-(invsqrt32*((5 + 7*c2b)*c2g*ca + 2*(1 - 7*c2b)*cb*s2g*sa)*sb)
            rotm(0,-2)=-((5 + 7*c2b)*eigth*s2g*sb**2*sqrt5)
            rotm(1,-2)=-(invsqrt128*(-2*ca*s2b*s2g + 3*c2g*sa*sb + 7*c2g*sa*Sin(3*be) + 7*ca*s2g*Sin(4*be)))
            rotm(2,-2)=-(c2g*eigth*s2a*(cb + 7*Cos(3*be))) - c2a*inv16*s2g*(5 + 4*c2b + 7*Cos(4*be))
            rotm(3,-2)=eigth*sqrt7o2*(8*cb**3*s2g*sb*Cos(3*al) + c2g*Sin(3*al)*(-sb + 3*Sin(3*be)))
            rotm(4,-2)=-(eigth*sb**2*sqrt7*((3 + c2b)*s2g*Cos(4*al) + 4*c2g*cb*Sin(4*al)))
            rotm(-4,-1)=half*sb**3*sqrt7o2*(cg*Cos(4*al) - cb*sg*Sin(4*al))
            rotm(-3,-1)=quarter*sb**2*sqrt7*(3*cb*cg*Cos(3*al) - (1 + 2*c2b)*sg*Sin(3*al))
            rotm(-2,-1)=invsqrt128*(3*c2a*cg*sb + 2*s2a*s2b*sg + 7*c2a*cg*Sin(3*be) - 7*s2a*sg*Sin(4*be))
            rotm(-1,-1)=inv16*(ca*cg*(9*cb + 7*Cos(3*be)) - 2*sa*sg*(c2b + 7*Cos(4*be)))
            rotm(0,-1)=(1 + 7*c2b)*eigth*s2b*sg*sqrt5o2
            rotm(1,-1)=inv16*(cg*sa*(9*cb + 7*Cos(3*be)) + 2*ca*sg*(c2b + 7*Cos(4*be)))
            rotm(2,-1)=-(invsqrt32*sb*((5 + 7*c2b)*cg*s2a + 5*c2a*cb*sg + 7*c2a*sg*Cos(3*be)))
            rotm(3,-1)=quarter*sb**2*sqrt7*((1 + 2*c2b)*sg*Cos(3*al) + 3*cb*cg*Sin(3*al))
            rotm(4,-1)=-(half*sb**3*sqrt7o2*(cb*sg*Cos(4*al) + cg*Sin(4*al)))
            rotm(-4,0)=eigth*sb**4*sqrt35*Sin(4*al)
            rotm(-3,0)=cb*half*sb**3*sqrt35o2*Sin(3*al)
            rotm(-2,0)=(5 + 7*c2b)*eigth*s2a*sb**2*sqrt5
            rotm(-1,0)=inv16*sa*sqrt5o2*(2*s2b + 7*Sin(4*be))
            rotm(0,0)=inv64*(9 + 20*c2b + 35*Cos(4*be))
            rotm(1,0)=-(ca*inv16*sqrt5o2*(2*s2b + 7*Sin(4*be)))
            rotm(2,0)=c2a*(5 + 7*c2b)*eigth*sb**2*sqrt5
            rotm(3,0)=-(cb*half*sb**3*sqrt35o2*Cos(3*al))
            rotm(4,0)=eigth*sb**4*sqrt35*Cos(4*al)
            rotm(-4,1)=-(half*sb**3*sqrt7o2*(sg*Cos(4*al) + cb*cg*Sin(4*al)))
            rotm(-3,1)=-(quarter*sb**2*sqrt7*(3*cb*sg*Cos(3*al) + (1 + 2*c2b)*cg*Sin(3*al)))
            rotm(-2,1)=-(invsqrt128*(-2*cg*s2a*s2b + 3*c2a*sb*sg + 7*c2a*sg*Sin(3*be) + 7*cg*s2a*Sin(4*be)))
            rotm(-1,1)=inv32*(-2*ca*sg*(9*cb + 7*Cos(3*be)) - 4*cg*sa*(c2b + 7*Cos(4*be)))
            rotm(0,1)=cg*inv16*sqrt5o2*(2*s2b + 7*Sin(4*be))
            rotm(1,1)=eigth*(-((1 + 7*c2b)*cb*sa*sg) + ca*cg*(c2b + 7*Cos(4*be)))
            rotm(2,1)=invsqrt128*(2*c2a*cg*s2b + 3*s2a*sb*sg + 7*s2a*sg*Sin(3*be) - 7*c2a*cg*Sin(4*be))
            rotm(3,1)=quarter*sb**2*sqrt7*((1 + 2*c2b)*cg*Cos(3*al) - 3*cb*sg*Sin(3*al))
            rotm(4,1)=half*sb**3*sqrt7o2*(-(cb*cg*Cos(4*al)) + sg*Sin(4*al))
            rotm(-4,2)=eigth*sb**2*sqrt7*(4*cb*s2g*Cos(4*al) + (3 + c2b)*c2g*Sin(4*al))
            rotm(-3,2)=eigth*sqrt7o2*(8*c2g*cb**3*sb*Sin(3*al) + s2g*Cos(3*al)*(-sb + 3*Sin(3*be)))
            rotm(-2,2)=inv16*(2*c2a*s2g*(cb + 7*Cos(3*be)) + c2g*s2a*(5 + 4*c2b + 7*Cos(4*be)))
            rotm(-1,2)=-(invsqrt128*(-2*c2g*s2b*sa + 3*ca*s2g*sb + 7*ca*s2g*Sin(3*be) + 7*c2g*sa*Sin(4*be)))
            rotm(0,2)=(5 + 7*c2b)*c2g*eigth*sb**2*sqrt5
            rotm(1,2)=invsqrt32*sb*(5*c2g*ca*cb - (5 + 7*c2b)*s2g*sa + 7*c2g*ca*Cos(3*be))
            rotm(2,2)=inv16*(-2*s2a*s2g*(cb + 7*Cos(3*be)) + c2a*c2g*(5 + 4*c2b + 7*Cos(4*be)))
            rotm(3,2)=-(eigth*sqrt7o2*(8*c2g*cb**3*sb*Cos(3*al) + s2g*Sin(3*al)*(sb - 3*Sin(3*be))))
            rotm(4,2)=eigth*sb**2*sqrt7*((3 + c2b)*c2g*Cos(4*al) - 4*cb*s2g*Sin(4*al))
            rotm(-4,3)=invsqrt2048*(-2*Cos(3*gm)*Sin(4*al)*(14*s2b + Sin(4*be)) - 4*Cos(4*al)*(7*sb + 3*Sin(3*be))*Sin(3*gm))
            rotm(-3,3)=-(eigth*(7*c2b + Cos(4*be))*Cos(3*gm)*Sin(3*al)) - inv16*Cos(3*al)*(7*cb + 9*Cos(3*be))*Sin(3*gm)
            rotm(-2,3)=eigth*sqrt7o2*(8*cb**3*s2a*sb*Cos(3*gm) + c2a*(-sb + 3*Sin(3*be))*Sin(3*gm))
            rotm(-1,3)=-(quarter*sb**2*sqrt7*((1 + 2*c2b)*sa*Cos(3*gm) + 3*ca*cb*Sin(3*gm)))
            rotm(0,3)=cb*half*sb**3*sqrt35o2*Cos(3*gm)
            rotm(1,3)=quarter*sb**2*sqrt7*((1 + 2*c2b)*ca*Cos(3*gm) - 3*cb*sa*Sin(3*gm))
            rotm(2,3)=eigth*sqrt7o2*(8*c2a*cb**3*sb*Cos(3*gm) + s2a*(sb - 3*Sin(3*be))*Sin(3*gm))
            rotm(3,3)=eigth*Cos(3*al)*(7*c2b + Cos(4*be))*Cos(3*gm) - inv16*(7*cb + 9*Cos(3*be))*Sin(3*al)*Sin(3*gm)
            rotm(4,3)=invsqrt2048*(-2*Cos(4*al)*Cos(3*gm)*(14*s2b + Sin(4*be)) + 4*Sin(4*al)*(7*sb + 3*Sin(3*be))*Sin(3*gm))
            rotm(-4,4)=inv64*((35 + 28*c2b + Cos(4*be))*Cos(4*gm)*Sin(4*al) + 8*Cos(4*al)*(7*cb + Cos(3*be))*Sin(4*gm))
            rotm(-3,4)=invsqrt2048*(-2*Cos(4*gm)*Sin(3*al)*(14*s2b + Sin(4*be)) - 4*Cos(3*al)*(7*sb + 3*Sin(3*be))*Sin(4*gm))
            rotm(-2,4)=eigth*sb**2*sqrt7*((3 + c2b)*s2a*Cos(4*gm) + 4*c2a*cb*Sin(4*gm))
            rotm(-1,4)=-(half*sb**3*sqrt7o2*(cb*sa*Cos(4*gm) + ca*Sin(4*gm)))
            rotm(0,4)=eigth*sb**4*sqrt35*Cos(4*gm)
            rotm(1,4)=half*sb**3*sqrt7o2*(ca*cb*Cos(4*gm) - sa*Sin(4*gm))
            rotm(2,4)=eigth*sb**2*sqrt7*(c2a*(3 + c2b)*Cos(4*gm) - 4*cb*s2a*Sin(4*gm))
            rotm(3,4)=invsqrt512*(Cos(3*al)*Cos(4*gm)*(14*s2b + Sin(4*be)) - 2*Sin(3*al)*(7*sb + 3*Sin(3*be))*Sin(4*gm))
            rotm(4,4)=inv64*(Cos(4*al)*(35 + 28*c2b + Cos(4*be))*Cos(4*gm) - 8*(7*cb + Cos(3*be))*Sin(4*al)*Sin(4*gm))
        case(5) ! 11x11, still works!
            rotm(-5,-5)=inv256*(2*Cos(5*al)*(63 + 60*c2b + 5*Cos(4*be))*Cos(5*gm) - (210*cb + 45*Cos(3*be) + Cos(5*be))*Sin(5*al)*Sin(5*gm))
            rotm(-4,-5)=inv128*sqrt5o2*(-8*Cos(4*al)*Cos(5*gm)*(6*s2b + Sin(4*be)) + Sin(4*al)*(42*sb + 27*Sin(3*be) + Sin(5*be))*Sin(5*gm))
            rotm(-3,-5)=3*inv64*sb**2*sqrt5*(2*(5 + 3*c2b)*Cos(3*al)*Cos(5*gm) - (15*cb + Cos(3*be))*Sin(3*al)*Sin(5*gm))
            rotm(-2,-5)=eigth*sb**3*sqrt15o2*(-4*c2a*cb*Cos(5*gm) + (3 + c2b)*s2a*Sin(5*gm))
            rotm(-1,-5)=eigth*sb**4*sqrt105o2*(ca*Cos(5*gm) - cb*sa*Sin(5*gm))
            rotm(0,-5)=3*eigth*sb**5*sg*sqrt7o2*(1 + 2*c2g + 2*Cos(4*gm))
            rotm(1,-5)=eigth*sb**4*sqrt105o2*(sa*Cos(5*gm) + ca*cb*Sin(5*gm))
            rotm(2,-5)=eigth*sb**3*sqrt15o2*(4*cb*s2a*Cos(5*gm) + c2a*(3 + c2b)*Sin(5*gm))
            rotm(3,-5)=3*inv64*sb**2*sqrt5*(2*(5 + 3*c2b)*Cos(5*gm)*Sin(3*al) + Cos(3*al)*(15*cb + Cos(3*be))*Sin(5*gm))
            rotm(4,-5)=inv128*sqrt5o2*(8*Cos(5*gm)*Sin(4*al)*(6*s2b + Sin(4*be)) + Cos(4*al)*(42*sb + 27*Sin(3*be) + Sin(5*be))*Sin(5*gm))
            rotm(5,-5)=inv256*(2*(63 + 60*c2b + 5*Cos(4*be))*Cos(5*gm)*Sin(5*al) + Cos(5*al)*(210*cb + 45*Cos(3*be) + Cos(5*be))*Sin(5*gm))
            rotm(-5,-4)=inv128*sqrt5o2*(8*Cos(5*al)*Cos(4*gm)*(6*s2b + Sin(4*be)) - Sin(5*al)*(42*sb + 27*Sin(3*be) + Sin(5*be))*Sin(4*gm))
            rotm(-4,-4)=quarter*Cos(4*al)*(3*c2b + Cos(4*be))*Cos(4*gm) - inv128*(42*cb + 81*Cos(3*be) + 5*Cos(5*be))*Sin(4*al)*Sin(4*gm)
            rotm(-3,-4)=-3*inv128*invsqrt2*(8*Cos(3*al)*Cos(4*gm)*(2*s2b + 3*Sin(4*be)) + Sin(3*al)*(14*sb - 39*Sin(3*be) - 5*Sin(5*be))*Sin(4*gm))
            rotm(-2,-4)=inv16*sb**2*sqrt3*(8*c2a*(1 + 2*c2b)*Cos(4*gm) - s2a*(19*cb + 5*Cos(3*be))*Sin(4*gm))
            rotm(-1,-4)=inv16*sb**3*sqrt21*(-8*ca*cb*Cos(4*gm) + (3 + 5*c2b)*sa*Sin(4*gm))
            rotm(0,-4)=-3*cb*eigth*sb**4*sqrt35*Sin(4*gm)
            rotm(1,-4)=-(inv16*sb**3*sqrt21*(8*cb*sa*Cos(4*gm) + (3 + 5*c2b)*ca*Sin(4*gm)))
            rotm(2,-4)=-(inv16*sb**2*sqrt3*(8*(1 + 2*c2b)*s2a*Cos(4*gm) + c2a*(19*cb + 5*Cos(3*be))*Sin(4*gm)))
            rotm(3,-4)=-3*inv128*invsqrt2*(8*Cos(4*gm)*Sin(3*al)*(2*s2b + 3*Sin(4*be)) + Cos(3*al)*(-14*sb + 39*Sin(3*be) + 5*Sin(5*be))*Sin(4*gm))
            rotm(4,-4)=-(quarter*(3*c2b + Cos(4*be))*Cos(4*gm)*Sin(4*al)) - inv128*Cos(4*al)*(42*cb + 81*Cos(3*be) + 5*Cos(5*be))*Sin(4*gm)
            rotm(5,-4)=inv128*sqrt5o2*(8*Cos(4*gm)*Sin(5*al)*(6*s2b + Sin(4*be)) + Cos(5*al)*(42*sb + 27*Sin(3*be) + Sin(5*be))*Sin(4*gm))
            rotm(-5,-3)=3*inv64*sb**2*sqrt5*(2*(5 + 3*c2b)*Cos(5*al)*Cos(3*gm) - (15*cb + Cos(3*be))*Sin(5*al)*Sin(3*gm))
            rotm(-4,-3)=3*inv128*invsqrt2*(8*Cos(4*al)*Cos(3*gm)*(2*s2b + 3*Sin(4*be)) + Sin(4*al)*(14*sb - 39*Sin(3*be) - 5*Sin(5*be))*Sin(3*gm))
            rotm(-3,-3)=inv256*(2*Cos(3*al)*(35 + 12*c2b + 81*Cos(4*be))*Cos(3*gm) - (42*cb + 169*Cos(3*be) + 45*Cos(5*be))*Sin(3*al)*Sin(3*gm))
            rotm(-2,-3)=inv64*sqrt3o2*(4*c2a*Cos(3*gm)*(2*s2b - 9*Sin(4*be)) + s2a*(14*sb + 13*Sin(3*be) + 15*Sin(5*be))*Sin(3*gm))
            rotm(-1,-3)=inv32*sb**2*sqrt21o2*(2*(7 + 9*c2b)*ca*Cos(3*gm) - sa*(17*cb + 15*Cos(3*be))*Sin(3*gm))
            rotm(0,-3)=(7 + 9*c2b)*inv16*sb**3*sqrt35o2*Sin(3*gm)
            rotm(1,-3)=inv32*sb**2*sqrt21o2*(2*(7 + 9*c2b)*sa*Cos(3*gm) + ca*(17*cb + 15*Cos(3*be))*Sin(3*gm))
            rotm(2,-3)=inv64*sqrt3o2*(4*s2a*Cos(3*gm)*(-2*s2b + 9*Sin(4*be)) + c2a*(14*sb + 13*Sin(3*be) + 15*Sin(5*be))*Sin(3*gm))
            rotm(3,-3)=inv256*(2*(35 + 12*c2b + 81*Cos(4*be))*Cos(3*gm)*Sin(3*al) + Cos(3*al)*(42*cb + 169*Cos(3*be) + 45*Cos(5*be))*Sin(3*gm))
            rotm(4,-3)=-3*inv128*invsqrt2*(8*Cos(3*gm)*Sin(4*al)*(2*s2b + 3*Sin(4*be)) + Cos(4*al)*(-14*sb + 39*Sin(3*be) + 5*Sin(5*be))*Sin(3*gm))
            rotm(5,-3)=3*inv64*sb**2*sqrt5*(2*(5 + 3*c2b)*Cos(3*gm)*Sin(5*al) + Cos(5*al)*(15*cb + Cos(3*be))*Sin(3*gm))
            rotm(-5,-2)=eigth*sb**3*sqrt15o2*(4*c2g*cb*Cos(5*al) - (3 + c2b)*s2g*Sin(5*al))
            rotm(-4,-2)=inv16*sb**2*sqrt3*(8*(1 + 2*c2b)*c2g*Cos(4*al) - s2g*(19*cb + 5*Cos(3*be))*Sin(4*al))
            rotm(-3,-2)=-(inv64*sqrt3o2*(4*c2g*Cos(3*al)*(2*s2b - 9*Sin(4*be)) + s2g*Sin(3*al)*(14*sb + 13*Sin(3*be) + 15*Sin(5*be))))
            rotm(-2,-2)=c2a*c2g*quarter*(c2b + 3*Cos(4*be)) - inv32*s2a*s2g*(14*cb + 3*Cos(3*be) + 15*Cos(5*be))
            rotm(-1,-2)=-(inv32*sb*sqrt7*(4*c2g*ca*(5*cb + 3*Cos(3*be)) - s2g*sa*(5 + 12*c2b + 15*Cos(4*be))))
            rotm(0,-2)=-((1 + 3*c2b)*cb*eigth*s2g*sb**2*sqrt105)
            rotm(1,-2)=inv64*sqrt7*(-4*c2g*sa*(2*s2b + 3*Sin(4*be)) + ca*s2g*(2*sb + 3*Sin(3*be) - 15*Sin(5*be)))
            rotm(2,-2)=-(c2g*quarter*s2a*(c2b + 3*Cos(4*be))) - c2a*inv32*s2g*(14*cb + 3*Cos(3*be) + 15*Cos(5*be))
            rotm(3,-2)=inv64*sqrt3o2*(4*c2g*Sin(3*al)*(-2*s2b + 9*Sin(4*be)) + s2g*Cos(3*al)*(14*sb + 13*Sin(3*be) + 15*Sin(5*be)))
            rotm(4,-2)=-(inv16*sb**2*sqrt3*(s2g*Cos(4*al)*(19*cb + 5*Cos(3*be)) + 8*(1 + 2*c2b)*c2g*Sin(4*al)))
            rotm(5,-2)=eigth*sb**3*sqrt15o2*((3 + c2b)*s2g*Cos(5*al) + 4*c2g*cb*Sin(5*al))
            rotm(-5,-1)=eigth*sb**4*sqrt105o2*(cg*Cos(5*al) - cb*sg*Sin(5*al))
            rotm(-4,-1)=inv16*sb**3*sqrt21*(8*cb*cg*Cos(4*al) - (3 + 5*c2b)*sg*Sin(4*al))
            rotm(-3,-1)=inv32*sb**2*sqrt21o2*(2*(7 + 9*c2b)*cg*Cos(3*al) - sg*(17*cb + 15*Cos(3*be))*Sin(3*al))
            rotm(-2,-1)=inv64*sqrt7*(4*c2a*cg*(2*s2b + 3*Sin(4*be)) + s2a*sg*(2*sb + 3*Sin(3*be) - 15*Sin(5*be)))
            rotm(-1,-1)=inv64*(cb*sa*sg*(-43 + 84*c2b - 105*Cos(4*be)) + ca*cg*(15 + 28*c2b + 21*Cos(4*be)))
            rotm(0,-1)=inv64*sb*sg*sqrt15*(15 + 28*c2b + 21*Cos(4*be))
            rotm(1,-1)=inv64*(cg*sa*(15 + 28*c2b + 21*Cos(4*be)) + ca*cb*sg*(43 - 84*c2b + 105*Cos(4*be)))
            rotm(2,-1)=inv64*sqrt7*(-4*cg*s2a*(2*s2b + 3*Sin(4*be)) + c2a*sg*(2*sb + 3*Sin(3*be) - 15*Sin(5*be)))
            rotm(3,-1)=inv32*sb**2*sqrt21o2*(sg*Cos(3*al)*(17*cb + 15*Cos(3*be)) + 2*(7 + 9*c2b)*cg*Sin(3*al))
            rotm(4,-1)=-(inv16*sb**3*sqrt21*((3 + 5*c2b)*sg*Cos(4*al) + 8*cb*cg*Sin(4*al)))
            rotm(5,-1)=eigth*sb**4*sqrt105o2*(cb*sg*Cos(5*al) + cg*Sin(5*al))
            rotm(-5,0)=3*eigth*sa*sb**5*sqrt7o2*(1 + 2*c2a + 2*Cos(4*al))
            rotm(-4,0)=3*cb*eigth*sb**4*sqrt35*Sin(4*al)
            rotm(-3,0)=(1 + 2*c2a)*(7 + 9*c2b)*inv16*sa*sb**3*sqrt35o2
            rotm(-2,0)=(1 + 3*c2b)*cb*eigth*s2a*sb**2*sqrt105
            rotm(-1,0)=inv64*sa*sb*sqrt15*(15 + 28*c2b + 21*Cos(4*be))
            rotm(0,0)=inv128*(30*cb + 35*Cos(3*be) + 63*Cos(5*be))
            rotm(1,0)=-(ca*inv128*sqrt15*(2*sb + 7*Sin(3*be) + 21*Sin(5*be)))
            rotm(2,0)=c2a*inv16*sb**2*sqrt105*(5*cb + 3*Cos(3*be))
            rotm(3,0)=-((7 + 9*c2b)*inv16*sb**3*sqrt35o2*Cos(3*al))
            rotm(4,0)=3*cb*eigth*sb**4*sqrt35*Cos(4*al)
            rotm(5,0)=-3*eigth*sb**5*sqrt7o2*Cos(5*al)
            rotm(-5,1)=-(eigth*sb**4*sqrt105o2*(sg*Cos(5*al) + cb*cg*Sin(5*al)))
            rotm(-4,1)=-(inv16*sb**3*sqrt21*(8*cb*sg*Cos(4*al) + (3 + 5*c2b)*cg*Sin(4*al)))
            rotm(-3,1)=-(inv32*sb**2*sqrt21o2*(2*(7 + 9*c2b)*sg*Cos(3*al) + cg*(17*cb + 15*Cos(3*be))*Sin(3*al)))
            rotm(-2,1)=inv64*sqrt7*(-4*c2a*sg*(2*s2b + 3*Sin(4*be)) + cg*s2a*(2*sb + 3*Sin(3*be) - 15*Sin(5*be)))
            rotm(-1,1)=inv128*(-2*ca*sg*(15 + 28*c2b + 21*Cos(4*be)) - cg*sa*(2*cb + 21*(Cos(3*be) + 5*Cos(5*be))))
            rotm(0,1)=cg*inv128*sqrt15*(2*sb + 7*Sin(3*be) + 21*Sin(5*be))
            rotm(1,1)=inv128*(-2*sa*sg*(15 + 28*c2b + 21*Cos(4*be)) + ca*cg*(2*cb + 21*(Cos(3*be) + 5*Cos(5*be))))
            rotm(2,1)=inv64*sqrt7*(4*s2a*sg*(2*s2b + 3*Sin(4*be)) + c2a*cg*(2*sb + 3*Sin(3*be) - 15*Sin(5*be)))
            rotm(3,1)=inv32*sb**2*sqrt21o2*(cg*Cos(3*al)*(17*cb + 15*Cos(3*be)) - 2*(7 + 9*c2b)*sg*Sin(3*al))
            rotm(4,1)=inv16*sb**3*sqrt21*(-((3 + 5*c2b)*cg*Cos(4*al)) + 8*cb*sg*Sin(4*al))
            rotm(5,1)=eigth*sb**4*sqrt105o2*(cb*cg*Cos(5*al) - sg*Sin(5*al))
            rotm(-5,2)=eigth*sb**3*sqrt15o2*(4*cb*s2g*Cos(5*al) + (3 + c2b)*c2g*Sin(5*al))
            rotm(-4,2)=inv16*sb**2*sqrt3*(8*(1 + 2*c2b)*s2g*Cos(4*al) + c2g*(19*cb + 5*Cos(3*be))*Sin(4*al))
            rotm(-3,2)=inv64*sqrt3o2*(4*s2g*Cos(3*al)*(-2*s2b + 9*Sin(4*be)) + c2g*Sin(3*al)*(14*sb + 13*Sin(3*be) + 15*Sin(5*be)))
            rotm(-2,2)=inv32*(8*c2a*s2g*(c2b + 3*Cos(4*be)) + c2g*s2a*(14*cb + 3*Cos(3*be) + 15*Cos(5*be)))
            rotm(-1,2)=inv64*sqrt7*(-4*ca*s2g*(2*s2b + 3*Sin(4*be)) + c2g*sa*(2*sb + 3*Sin(3*be) - 15*Sin(5*be)))
            rotm(0,2)=(1 + 3*c2b)*c2g*cb*eigth*sb**2*sqrt105
            rotm(1,2)=inv32*sb*sqrt7*(-4*s2g*sa*(5*cb + 3*Cos(3*be)) + c2g*ca*(5 + 12*c2b + 15*Cos(4*be)))
            rotm(2,2)=inv32*(-8*s2a*s2g*(c2b + 3*Cos(4*be)) + c2a*c2g*(14*cb + 3*Cos(3*be) + 15*Cos(5*be)))
            rotm(3,2)=-(inv64*sqrt3o2*(4*s2g*Sin(3*al)*(2*s2b - 9*Sin(4*be)) + c2g*Cos(3*al)*(14*sb + 13*Sin(3*be) + 15*Sin(5*be))))
            rotm(4,2)=inv16*sb**2*sqrt3*(c2g*Cos(4*al)*(19*cb + 5*Cos(3*be)) - 8*(1 + 2*c2b)*s2g*Sin(4*al))
            rotm(5,2)=eigth*sb**3*sqrt15o2*(-((3 + c2b)*c2g*Cos(5*al)) + 4*cb*s2g*Sin(5*al))
            rotm(-5,3)=-3*inv64*sb**2*sqrt5*((15*cb + Cos(3*be))*Cos(3*gm)*Sin(5*al) + 2*(5 + 3*c2b)*Cos(5*al)*Sin(3*gm))
            rotm(-4,3)=3*inv128*invsqrt2*(Cos(3*gm)*Sin(4*al)*(14*sb - 39*Sin(3*be) - 5*Sin(5*be)) - 8*Cos(4*al)*(2*s2b + 3*Sin(4*be))*Sin(3*gm))
            rotm(-3,3)=inv256*(-((42*cb + 169*Cos(3*be) + 45*Cos(5*be))*Cos(3*gm)*Sin(3*al)) - 2*Cos(3*al)*(35 + 12*c2b + 81*Cos(4*be))*Sin(3*gm))
            rotm(-2,3)=inv64*sqrt3o2*(s2a*Cos(3*gm)*(14*sb + 13*Sin(3*be) + 15*Sin(5*be)) + 4*c2a*(-2*s2b + 9*Sin(4*be))*Sin(3*gm))
            rotm(-1,3)=-(inv32*sb**2*sqrt21o2*(sa*(17*cb + 15*Cos(3*be))*Cos(3*gm) + 2*(7 + 9*c2b)*ca*Sin(3*gm)))
            rotm(0,3)=(7 + 9*c2b)*inv16*sb**3*sqrt35o2*Cos(3*gm)
            rotm(1,3)=inv32*sb**2*sqrt21o2*(ca*(17*cb + 15*Cos(3*be))*Cos(3*gm) - 2*(7 + 9*c2b)*sa*Sin(3*gm))
            rotm(2,3)=inv64*sqrt3o2*(c2a*Cos(3*gm)*(14*sb + 13*Sin(3*be) + 15*Sin(5*be)) + 4*s2a*(2*s2b - 9*Sin(4*be))*Sin(3*gm))
            rotm(3,3)=inv256*(Cos(3*al)*(42*cb + 169*Cos(3*be) + 45*Cos(5*be))*Cos(3*gm) - 2*(35 + 12*c2b + 81*Cos(4*be))*Sin(3*al)*Sin(3*gm))
            rotm(4,3)=3*inv128*invsqrt2*(Cos(4*al)*Cos(3*gm)*(14*sb - 39*Sin(3*be) - 5*Sin(5*be)) + 8*Sin(4*al)*(2*s2b + 3*Sin(4*be))*Sin(3*gm))
            rotm(5,3)=3*inv64*sb**2*sqrt5*(Cos(5*al)*(15*cb + Cos(3*be))*Cos(3*gm) - 2*(5 + 3*c2b)*Sin(5*al)*Sin(3*gm))
            rotm(-5,4)=inv128*sqrt5o2*(Cos(4*gm)*Sin(5*al)*(42*sb + 27*Sin(3*be) + Sin(5*be)) + 8*Cos(5*al)*(6*s2b + Sin(4*be))*Sin(4*gm))
            rotm(-4,4)=inv128*(42*cb + 81*Cos(3*be) + 5*Cos(5*be))*Cos(4*gm)*Sin(4*al) + quarter*Cos(4*al)*(3*c2b + Cos(4*be))*Sin(4*gm)
            rotm(-3,4)=3*inv128*invsqrt2*(Cos(4*gm)*Sin(3*al)*(14*sb - 39*Sin(3*be) - 5*Sin(5*be)) - 8*Cos(3*al)*(2*s2b + 3*Sin(4*be))*Sin(4*gm))
            rotm(-2,4)=inv16*sb**2*sqrt3*(s2a*(19*cb + 5*Cos(3*be))*Cos(4*gm) + 8*c2a*(1 + 2*c2b)*Sin(4*gm))
            rotm(-1,4)=-(inv16*sb**3*sqrt21*((3 + 5*c2b)*sa*Cos(4*gm) + 8*ca*cb*Sin(4*gm)))
            rotm(0,4)=3*cb*eigth*sb**4*sqrt35*Cos(4*gm)
            rotm(1,4)=inv16*sb**3*sqrt21*((3 + 5*c2b)*ca*Cos(4*gm) - 8*cb*sa*Sin(4*gm))
            rotm(2,4)=inv16*sb**2*sqrt3*(c2a*(19*cb + 5*Cos(3*be))*Cos(4*gm) - 8*(1 + 2*c2b)*s2a*Sin(4*gm))
            rotm(3,4)=-3*inv128*invsqrt2*(Cos(3*al)*Cos(4*gm)*(14*sb - 39*Sin(3*be) - 5*Sin(5*be)) + 8*Sin(3*al)*(2*s2b + 3*Sin(4*be))*Sin(4*gm))
            rotm(4,4)=inv128*Cos(4*al)*(42*cb + 81*Cos(3*be) + 5*Cos(5*be))*Cos(4*gm) - quarter*(3*c2b + Cos(4*be))*Sin(4*al)*Sin(4*gm)
            rotm(5,4)=inv128*sqrt5o2*(-(Cos(5*al)*Cos(4*gm)*(42*sb + 27*Sin(3*be) + Sin(5*be))) + 8*Sin(5*al)*(6*s2b + Sin(4*be))*Sin(4*gm))
            rotm(-5,5)=inv256*(-((210*cb + 45*Cos(3*be) + Cos(5*be))*Cos(5*gm)*Sin(5*al)) - 2*Cos(5*al)*(63 + 60*c2b + 5*Cos(4*be))*Sin(5*gm))
            rotm(-4,5)=inv128*sqrt5o2*(Cos(5*gm)*Sin(4*al)*(42*sb + 27*Sin(3*be) + Sin(5*be)) + 8*Cos(4*al)*(6*s2b + Sin(4*be))*Sin(5*gm))
            rotm(-3,5)=-3*inv64*sb**2*sqrt5*((15*cb + Cos(3*be))*Cos(5*gm)*Sin(3*al) + 2*(5 + 3*c2b)*Cos(3*al)*Sin(5*gm))
            rotm(-2,5)=eigth*sb**3*sqrt15o2*((3 + c2b)*s2a*Cos(5*gm) + 4*c2a*cb*Sin(5*gm))
            rotm(-1,5)=-(eigth*sb**4*sqrt105o2*(cb*sa*Cos(5*gm) + ca*Sin(5*gm)))
            rotm(0,5)=3*eigth*sb**5*sqrt7o2*Cos(5*gm)
            rotm(1,5)=eigth*sb**4*sqrt105o2*(ca*cb*Cos(5*gm) - sa*Sin(5*gm))
            rotm(2,5)=eigth*sb**3*sqrt15o2*(c2a*(3 + c2b)*Cos(5*gm) - 4*cb*s2a*Sin(5*gm))
            rotm(3,5)=3*inv64*sb**2*sqrt5*(Cos(3*al)*(15*cb + Cos(3*be))*Cos(5*gm) - 2*(5 + 3*c2b)*Sin(3*al)*Sin(5*gm))
            rotm(4,5)=inv128*sqrt5o2*(Cos(4*al)*Cos(5*gm)*(42*sb + 27*Sin(3*be) + Sin(5*be)) - 8*Sin(4*al)*(6*s2b + Sin(4*be))*Sin(5*gm))
            rotm(5,5)=inv256*(Cos(5*al)*(210*cb + 45*Cos(3*be) + Cos(5*be))*Cos(5*gm) - 2*(63 + 60*c2b + 5*Cos(4*be))*Sin(5*al)*Sin(5*gm))
        case default
        end select
    end block getrm

    ! fix inversion
    if ( inversion ) then
        if ( mod(l,2) .ne. 0 ) rotm=-rotm
    endif
    ! and slice away tiny elements, set zeros to zero and ones to one.
    rotm=lo_chop(rotm,1E-11_r8)
end subroutine

end module
